<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/controller/auth/AuthController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/controller/auth/AuthController.java" />
              <option name="originalContent" value="package com.smartlab.zippy.controller.auth;&#10;&#10;import com.smartlab.zippy.service.auth.JwtService;&#10;import com.smartlab.zippy.model.dto.web.request.auth.LoginRequest;&#10;import com.smartlab.zippy.model.dto.web.request.auth.RefreshTokenRequest;&#10;import com.smartlab.zippy.model.dto.web.request.auth.RegisterRequest;&#10;import com.smartlab.zippy.model.dto.web.request.auth.VerifyRequest;&#10;import com.smartlab.zippy.model.dto.web.response.ApiResponse;&#10;import com.smartlab.zippy.model.dto.web.response.auth.LoginResponse;&#10;import com.smartlab.zippy.model.dto.web.response.auth.RegisterResponse;&#10;import com.smartlab.zippy.model.dto.web.response.auth.VerifyResponse;&#10;import com.smartlab.zippy.model.entity.User;&#10;import com.smartlab.zippy.repository.UserRepository;&#10;import com.smartlab.zippy.service.auth.OtpService;&#10;import com.smartlab.zippy.service.auth.TokenService;&#10;import com.smartlab.zippy.service.auth.UserService;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.validation.Valid;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.core.AuthenticationException;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.validation.BindingResult;&#10;import org.springframework.validation.FieldError;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/auth&quot;)&#10;public class AuthController {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AuthController.class);&#10;&#10;    private final AuthenticationManager authenticationManager;&#10;    private final JwtService jwtService;&#10;    private final UserService userService;&#10;    private final OtpService otpService;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final UserRepository userRepository;&#10;    private final TokenService tokenService;&#10;    private final UserDetailsService userDetailsService;&#10;&#10;    @Autowired&#10;    public AuthController(AuthenticationManager authenticationManager,&#10;                          JwtService jwtService,&#10;                          UserService userService,&#10;                          OtpService otpService,&#10;                          PasswordEncoder passwordEncoder,&#10;                          UserRepository userRepository,&#10;                          TokenService tokenService,&#10;                          UserDetailsService userDetailsService) {&#10;        this.authenticationManager = authenticationManager;&#10;        this.jwtService = jwtService;&#10;        this.userService = userService;&#10;        this.otpService = otpService;&#10;        this.passwordEncoder = passwordEncoder;&#10;        this.userRepository = userRepository;&#10;        this.tokenService = tokenService;&#10;        this.userDetailsService = userDetailsService;&#10;    }&#10;&#10;    /**&#10;     * User login endpoint&#10;     *&#10;     * @param loginRequest Login credentials&#10;     * @return JWT tokens on successful authentication&#10;     */&#10;    @PostMapping(&quot;/login&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoginResponse&gt;&gt; login(@Valid @RequestBody LoginRequest loginRequest) {&#10;        logger.info(&quot;Login attempt for user: {}&quot;, loginRequest.getCredential());&#10;&#10;        try {&#10;            // First, find the user to check status before authentication&#10;            Optional&lt;User&gt; userOptional = userRepository.findByUsername(loginRequest.getCredential());&#10;&#10;            if (userOptional.isEmpty()) {&#10;                userOptional = userRepository.findByEmail(loginRequest.getCredential());&#10;            }&#10;&#10;            // Check if user is present before calling get()&#10;            if (userOptional.isEmpty()) {&#10;                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                        .body(ApiResponse.error(&quot;Invalid username or password&quot;));&#10;            }&#10;&#10;            User user = userOptional.get();&#10;&#10;            // Check if user status is PENDING&#10;            if (&quot;PENDING&quot;.equals(user.getStatus())) {&#10;                logger.info(&quot;User {} has PENDING status, needs verification&quot;, loginRequest.getCredential());&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(ApiResponse.error(&quot;Email verification required&quot;));&#10;            }&#10;&#10;            // Authenticate the user&#10;            Authentication authentication = authenticationManager.authenticate(&#10;                    new UsernamePasswordAuthenticationToken(&#10;                            loginRequest.getCredential(),&#10;                            loginRequest.getPassword()&#10;                    )&#10;            );&#10;&#10;            // Get user details from the authentication object&#10;            UserDetails userDetails = (UserDetails) authentication.getPrincipal();&#10;&#10;            // Generate access and refresh tokens&#10;            String accessToken = jwtService.generateAccessToken(userDetails);&#10;            String refreshToken = jwtService.generateRefreshToken(userDetails);&#10;&#10;            // Build and return successful response&#10;            ApiResponse&lt;LoginResponse&gt; response = ApiResponse.success(&#10;                    LoginResponse.builder()&#10;                            .accessToken(accessToken)&#10;                            .refreshToken(refreshToken)&#10;                            .verificationRequired(false)&#10;                            .build(),&#10;                    &quot;User logged in successfully&quot;&#10;            );&#10;&#10;            logger.info(&quot;User {} successfully logged in&quot;, userDetails.getUsername());&#10;            return ResponseEntity.ok(response);&#10;&#10;        } catch (AuthenticationException e) {&#10;            logger.error(&quot;Authentication failed for user: {}&quot;, loginRequest.getCredential(), e);&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(ApiResponse.error(&quot;Invalid username or password&quot;));&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Login failed for user: {}&quot;, loginRequest.getCredential(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;An error occurred during login&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * User registration endpoint&#10;     *&#10;     * @param registerRequest Registration data&#10;     * @param bindingResult   Validation results&#10;     * @return Registration status&#10;     */&#10;    @PostMapping(&quot;/register&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;RegisterResponse&gt;&gt; register(&#10;            @Valid @RequestBody RegisterRequest registerRequest,&#10;            BindingResult bindingResult) {&#10;&#10;        logger.info(&quot;Registration attempt for email: {}&quot;, registerRequest.getEmail());&#10;&#10;        // Check for validation errors&#10;        if (bindingResult.hasErrors()) {&#10;            Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;            bindingResult.getAllErrors().forEach(error -&gt; {&#10;                String fieldName = ((FieldError) error).getField();&#10;                String errorMessage = error.getDefaultMessage();&#10;                errors.put(fieldName, errorMessage);&#10;            });&#10;            return ResponseEntity.badRequest().body(ApiResponse.error(errors.toString()));&#10;        }&#10;&#10;        // Check if passwords match&#10;        if (!registerRequest.isPasswordMatching()) {&#10;            Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;            errors.put(&quot;confirmPassword&quot;, &quot;Password and confirmation do not match&quot;);&#10;            return ResponseEntity.badRequest().body(ApiResponse.error(errors.toString()));&#10;        }&#10;&#10;        // Check if email already exists&#10;        Optional&lt;User&gt; existingUser = userRepository.findByEmail(registerRequest.getEmail());&#10;        if (existingUser.isPresent()) {&#10;            String status = existingUser.get().getStatus();&#10;            if (&quot;ACTIVE&quot;.equals(status)) {&#10;                logger.warn(&quot;Email already registered: {}&quot;, registerRequest.getEmail());&#10;                return ResponseEntity.badRequest().body(&#10;                        ApiResponse.error(&quot;Email already registered&quot;));&#10;            } else if (&quot;PENDING&quot;.equals(status)) {&#10;                logger.warn(&quot;Email verification pending for: {}&quot;, registerRequest.getEmail());&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(&#10;                        ApiResponse.error(&quot;Email verification pending&quot;));&#10;            }&#10;        }&#10;&#10;        // Create the user&#10;        User newUser = userService.createUser(registerRequest);&#10;&#10;        // Generate and send OTP&#10;        String otp = otpService.generateOtp(newUser.getEmail());&#10;        otpService.sendOtp(newUser.getEmail(), otp);&#10;&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(&#10;                ApiResponse.success(&#10;                        RegisterResponse.builder()&#10;                                .verificationLink(&quot;/verify-otp?email=&quot; + newUser.getEmail())&#10;                                .emailVerificationRequired(true)&#10;                                .build(), &quot;Registration successful, please verify your email with the OTP sent&quot;&#10;                )&#10;        );&#10;    }&#10;&#10;    /**&#10;     * OTP verification endpoint&#10;     *&#10;     * @param verifyRequest Request containing email and OTP&#10;     * @return Verification status&#10;     */&#10;    @PostMapping(&quot;/verify-otp&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;VerifyResponse&gt;&gt; verifyOtp(&#10;            @Valid @RequestBody VerifyRequest verifyRequest) {&#10;&#10;        String email;&#10;        Optional&lt;User&gt; userOptional = userRepository.findByEmail(verifyRequest.getCredential());&#10;        if (userOptional.isPresent()) {&#10;            email = userOptional.get().getEmail();&#10;        } else {&#10;            userOptional = userRepository.findByUsername(verifyRequest.getCredential());&#10;            if (userOptional.isPresent()) {&#10;                email = userOptional.get().getEmail();&#10;            } else {&#10;                return ResponseEntity.badRequest().body(ApiResponse.error(&quot;User not found&quot;));&#10;            }&#10;        }&#10;&#10;        logger.info(&quot;OTP verification attempt for email: {}&quot;, email);&#10;&#10;        boolean isValid = otpService.validateOtp(email, verifyRequest.getOtp());&#10;&#10;        if (isValid) {&#10;&#10;            User user = userOptional.get();&#10;&#10;            // Activate user account&#10;            user.setStatus(&quot;ACTIVE&quot;);&#10;            userRepository.save(user);&#10;&#10;            logger.info(&quot;OTP verification successful for user: {}&quot;, verifyRequest.getCredential());&#10;//            return ResponseEntity.ok(ApiResponse.success(&quot;OTP verification successful&quot;));&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(&#10;                            VerifyResponse.builder().success(true).build(), &quot;OTP verification successful&quot;&#10;                    )&#10;            );&#10;        } else {&#10;            logger.warn(&quot;OTP verification failed for user: {}&quot;, verifyRequest.getCredential());&#10;            return ResponseEntity.badRequest().body(ApiResponse.error(&quot;Invalid or expired OTP&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resend OTP endpoint&#10;     *&#10;     * @param credential User email&#10;     * @return Status of OTP resend operation&#10;     */&#10;    @GetMapping(&quot;/resend-otp&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Object&gt;&gt; resendOtp(@RequestParam String credential) {&#10;        String email, otp;&#10;        Optional&lt;User&gt; userOptional = userRepository.findByEmail(credential);&#10;        if (userOptional.isPresent()) {&#10;            email = credential;&#10;        } else {&#10;            userOptional = userRepository.findByUsername(credential);&#10;            if (userOptional.isPresent()) {&#10;                email = userOptional.get().getEmail();&#10;            } else {&#10;                return ResponseEntity.badRequest().body(ApiResponse.error(&quot;User not found&quot;));&#10;            }&#10;        }&#10;        otp = otpService.generateOtp(email);&#10;        otpService.sendOtp(email, otp);&#10;        logger.info(&quot;OTP resent to email: {}&quot;, email);&#10;        return ResponseEntity.ok(ApiResponse.success(&quot;OTP resent successfully {}&quot;, email));&#10;    }&#10;&#10;    /**&#10;     * User logout endpoint&#10;     *&#10;     * @param request HTTP request containing the authorization header&#10;     * @return Success or error response&#10;     */&#10;    @PostMapping(&quot;/logout&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; logout(HttpServletRequest request) {&#10;        String authHeader = request.getHeader(&quot;Authorization&quot;);&#10;&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(ApiResponse.error(&quot;No authorization token provided&quot;));&#10;        }&#10;&#10;        String jwt = authHeader.substring(7);&#10;        String username = jwtService.extractUsername(jwt);&#10;&#10;        if (username != null) {&#10;            // Blacklist the access token&#10;            tokenService.blacklistAccessToken(jwt);&#10;&#10;            logger.info(&quot;User {} successfully logged out&quot;, username);&#10;            return ResponseEntity.ok(ApiResponse.success(null, &quot;Successfully logged out&quot;));&#10;        }&#10;&#10;        return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                .body(ApiResponse.error(&quot;Invalid token&quot;));&#10;    }&#10;&#10;    /**&#10;     * Refresh access token using refresh token&#10;     *&#10;     * @param refreshTokenRequest The refresh token request&#10;     * @return New access token and refresh token&#10;     */&#10;    @PostMapping(&quot;/refresh-token&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoginResponse&gt;&gt; refreshToken(@RequestBody RefreshTokenRequest refreshTokenRequest) {&#10;        String refreshToken = refreshTokenRequest.getRefreshToken();&#10;&#10;        // Validate refresh token&#10;        String username = tokenService.validateRefreshToken(refreshToken);&#10;&#10;        if (username == null) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(ApiResponse.error(&quot;Invalid refresh token&quot;));&#10;        }&#10;&#10;        // Load user details and generate new tokens&#10;        UserDetails userDetails = userDetailsService.loadUserByUsername(username);&#10;&#10;        // Revoke old refresh token&#10;        tokenService.revokeRefreshToken(refreshToken);&#10;&#10;        // Generate new tokens&#10;        String newAccessToken = jwtService.generateAccessToken(userDetails);&#10;        String newRefreshToken = jwtService.generateRefreshToken(userDetails);&#10;&#10;        ApiResponse&lt;LoginResponse&gt; response = ApiResponse.success(&#10;                LoginResponse.builder()&#10;                        .accessToken(newAccessToken)&#10;                        .refreshToken(newRefreshToken)&#10;                        .verificationRequired(false)&#10;                        .build(),&#10;                &quot;Tokens refreshed successfully&quot;&#10;        );&#10;&#10;        logger.info(&quot;Tokens refreshed for user: {}&quot;, username);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.controller.auth;&#10;&#10;import com.smartlab.zippy.service.auth.JwtService;&#10;import com.smartlab.zippy.model.dto.web.request.auth.LoginRequest;&#10;import com.smartlab.zippy.model.dto.web.request.auth.RefreshTokenRequest;&#10;import com.smartlab.zippy.model.dto.web.request.auth.RegisterRequest;&#10;import com.smartlab.zippy.model.dto.web.request.auth.VerifyRequest;&#10;import com.smartlab.zippy.model.dto.web.response.ApiResponse;&#10;import com.smartlab.zippy.model.dto.web.response.auth.LoginResponse;&#10;import com.smartlab.zippy.model.dto.web.response.auth.RegisterResponse;&#10;import com.smartlab.zippy.model.dto.web.response.auth.VerifyResponse;&#10;import com.smartlab.zippy.model.entity.User;&#10;import com.smartlab.zippy.repository.UserRepository;&#10;import com.smartlab.zippy.service.auth.OtpService;&#10;import com.smartlab.zippy.service.auth.TokenService;&#10;import com.smartlab.zippy.service.auth.UserService;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.validation.Valid;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.core.AuthenticationException;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.validation.BindingResult;&#10;import org.springframework.validation.FieldError;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/auth&quot;)&#10;public class AuthController {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AuthController.class);&#10;&#10;    private final AuthenticationManager authenticationManager;&#10;    private final JwtService jwtService;&#10;    private final UserService userService;&#10;    private final OtpService otpService;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final UserRepository userRepository;&#10;    private final TokenService tokenService;&#10;    private final UserDetailsService userDetailsService;&#10;&#10;    @Autowired&#10;    public AuthController(AuthenticationManager authenticationManager,&#10;                          JwtService jwtService,&#10;                          UserService userService,&#10;                          OtpService otpService,&#10;                          PasswordEncoder passwordEncoder,&#10;                          UserRepository userRepository,&#10;                          TokenService tokenService,&#10;                          UserDetailsService userDetailsService) {&#10;        this.authenticationManager = authenticationManager;&#10;        this.jwtService = jwtService;&#10;        this.userService = userService;&#10;        this.otpService = otpService;&#10;        this.passwordEncoder = passwordEncoder;&#10;        this.userRepository = userRepository;&#10;        this.tokenService = tokenService;&#10;        this.userDetailsService = userDetailsService;&#10;    }&#10;&#10;    /**&#10;     * User login endpoint&#10;     *&#10;     * @param loginRequest Login credentials&#10;     * @return JWT tokens on successful authentication&#10;     */&#10;    @PostMapping(&quot;/login&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoginResponse&gt;&gt; login(@Valid @RequestBody LoginRequest loginRequest) {&#10;        logger.info(&quot;Login attempt for user: {}&quot;, loginRequest.getCredential());&#10;&#10;        try {&#10;            // First, find the user to check status before authentication&#10;            Optional&lt;User&gt; userOptional = userRepository.findByUsername(loginRequest.getCredential());&#10;&#10;            if (userOptional.isEmpty()) {&#10;                userOptional = userRepository.findByEmail(loginRequest.getCredential());&#10;            }&#10;&#10;            // Check if user is present before calling get()&#10;            if (userOptional.isEmpty()) {&#10;                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                        .body(ApiResponse.error(&quot;Invalid username or password&quot;));&#10;            }&#10;&#10;            User user = userOptional.get();&#10;&#10;            // Check if user status is PENDING&#10;            if (&quot;PENDING&quot;.equals(user.getStatus())) {&#10;                logger.info(&quot;User {} has PENDING status, needs verification&quot;, loginRequest.getCredential());&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(ApiResponse.error(&quot;Email verification required&quot;));&#10;            }&#10;&#10;            // Authenticate the user&#10;            Authentication authentication = authenticationManager.authenticate(&#10;                    new UsernamePasswordAuthenticationToken(&#10;                            loginRequest.getCredential(),&#10;                            loginRequest.getPassword()&#10;                    )&#10;            );&#10;&#10;            // Get user details from the authentication object&#10;            UserDetails userDetails = (UserDetails) authentication.getPrincipal();&#10;&#10;            // Revoke all existing refresh tokens for this user before issuing new ones&#10;            logger.info(&quot;Revoking all existing tokens for user: {}&quot;, userDetails.getUsername());&#10;            tokenService.revokeAllUserTokens(userDetails.getUsername());&#10;&#10;            // Generate access and refresh tokens&#10;            String accessToken = jwtService.generateAccessToken(userDetails);&#10;            String refreshToken = jwtService.generateRefreshToken(userDetails);&#10;&#10;            // Build and return successful response&#10;            ApiResponse&lt;LoginResponse&gt; response = ApiResponse.success(&#10;                    LoginResponse.builder()&#10;                            .accessToken(accessToken)&#10;                            .refreshToken(refreshToken)&#10;                            .verificationRequired(false)&#10;                            .build(),&#10;                    &quot;User logged in successfully&quot;&#10;            );&#10;&#10;            logger.info(&quot;User {} successfully logged in&quot;, userDetails.getUsername());&#10;            return ResponseEntity.ok(response);&#10;&#10;        } catch (AuthenticationException e) {&#10;            logger.error(&quot;Authentication failed for user: {}&quot;, loginRequest.getCredential(), e);&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(ApiResponse.error(&quot;Invalid username or password&quot;));&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Login failed for user: {}&quot;, loginRequest.getCredential(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;An error occurred during login&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * User registration endpoint&#10;     *&#10;     * @param registerRequest Registration data&#10;     * @param bindingResult   Validation results&#10;     * @return Registration status&#10;     */&#10;    @PostMapping(&quot;/register&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;RegisterResponse&gt;&gt; register(&#10;            @Valid @RequestBody RegisterRequest registerRequest,&#10;            BindingResult bindingResult) {&#10;&#10;        logger.info(&quot;Registration attempt for email: {}&quot;, registerRequest.getEmail());&#10;&#10;        // Check for validation errors&#10;        if (bindingResult.hasErrors()) {&#10;            Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;            bindingResult.getAllErrors().forEach(error -&gt; {&#10;                String fieldName = ((FieldError) error).getField();&#10;                String errorMessage = error.getDefaultMessage();&#10;                errors.put(fieldName, errorMessage);&#10;            });&#10;            return ResponseEntity.badRequest().body(ApiResponse.error(errors.toString()));&#10;        }&#10;&#10;        // Check if passwords match&#10;        if (!registerRequest.isPasswordMatching()) {&#10;            Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;            errors.put(&quot;confirmPassword&quot;, &quot;Password and confirmation do not match&quot;);&#10;            return ResponseEntity.badRequest().body(ApiResponse.error(errors.toString()));&#10;        }&#10;&#10;        // Check if email already exists&#10;        Optional&lt;User&gt; existingUser = userRepository.findByEmail(registerRequest.getEmail());&#10;        if (existingUser.isPresent()) {&#10;            String status = existingUser.get().getStatus();&#10;            if (&quot;ACTIVE&quot;.equals(status)) {&#10;                logger.warn(&quot;Email already registered: {}&quot;, registerRequest.getEmail());&#10;                return ResponseEntity.badRequest().body(&#10;                        ApiResponse.error(&quot;Email already registered&quot;));&#10;            } else if (&quot;PENDING&quot;.equals(status)) {&#10;                logger.warn(&quot;Email verification pending for: {}&quot;, registerRequest.getEmail());&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(&#10;                        ApiResponse.error(&quot;Email verification pending&quot;));&#10;            }&#10;        }&#10;&#10;        // Create the user&#10;        User newUser = userService.createUser(registerRequest);&#10;&#10;        // Generate and send OTP&#10;        String otp = otpService.generateOtp(newUser.getEmail());&#10;        otpService.sendOtp(newUser.getEmail(), otp);&#10;&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(&#10;                ApiResponse.success(&#10;                        RegisterResponse.builder()&#10;                                .verificationLink(&quot;/verify-otp?email=&quot; + newUser.getEmail())&#10;                                .emailVerificationRequired(true)&#10;                                .build(), &quot;Registration successful, please verify your email with the OTP sent&quot;&#10;                )&#10;        );&#10;    }&#10;&#10;    /**&#10;     * OTP verification endpoint&#10;     *&#10;     * @param verifyRequest Request containing email and OTP&#10;     * @return Verification status&#10;     */&#10;    @PostMapping(&quot;/verify-otp&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;VerifyResponse&gt;&gt; verifyOtp(&#10;            @Valid @RequestBody VerifyRequest verifyRequest) {&#10;&#10;        String email;&#10;        Optional&lt;User&gt; userOptional = userRepository.findByEmail(verifyRequest.getCredential());&#10;        if (userOptional.isPresent()) {&#10;            email = userOptional.get().getEmail();&#10;        } else {&#10;            userOptional = userRepository.findByUsername(verifyRequest.getCredential());&#10;            if (userOptional.isPresent()) {&#10;                email = userOptional.get().getEmail();&#10;            } else {&#10;                return ResponseEntity.badRequest().body(ApiResponse.error(&quot;User not found&quot;));&#10;            }&#10;        }&#10;&#10;        logger.info(&quot;OTP verification attempt for email: {}&quot;, email);&#10;&#10;        boolean isValid = otpService.validateOtp(email, verifyRequest.getOtp());&#10;&#10;        if (isValid) {&#10;&#10;            User user = userOptional.get();&#10;&#10;            // Activate user account&#10;            user.setStatus(&quot;ACTIVE&quot;);&#10;            userRepository.save(user);&#10;&#10;            logger.info(&quot;OTP verification successful for user: {}&quot;, verifyRequest.getCredential());&#10;//            return ResponseEntity.ok(ApiResponse.success(&quot;OTP verification successful&quot;));&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(&#10;                            VerifyResponse.builder().success(true).build(), &quot;OTP verification successful&quot;&#10;                    )&#10;            );&#10;        } else {&#10;            logger.warn(&quot;OTP verification failed for user: {}&quot;, verifyRequest.getCredential());&#10;            return ResponseEntity.badRequest().body(ApiResponse.error(&quot;Invalid or expired OTP&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resend OTP endpoint&#10;     *&#10;     * @param credential User email&#10;     * @return Status of OTP resend operation&#10;     */&#10;    @GetMapping(&quot;/resend-otp&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Object&gt;&gt; resendOtp(@RequestParam String credential) {&#10;        String email, otp;&#10;        Optional&lt;User&gt; userOptional = userRepository.findByEmail(credential);&#10;        if (userOptional.isPresent()) {&#10;            email = credential;&#10;        } else {&#10;            userOptional = userRepository.findByUsername(credential);&#10;            if (userOptional.isPresent()) {&#10;                email = userOptional.get().getEmail();&#10;            } else {&#10;                return ResponseEntity.badRequest().body(ApiResponse.error(&quot;User not found&quot;));&#10;            }&#10;        }&#10;        otp = otpService.generateOtp(email);&#10;        otpService.sendOtp(email, otp);&#10;        logger.info(&quot;OTP resent to email: {}&quot;, email);&#10;        return ResponseEntity.ok(ApiResponse.success(&quot;OTP resent successfully {}&quot;, email));&#10;    }&#10;&#10;    /**&#10;     * User logout endpoint&#10;     *&#10;     * @param request HTTP request containing the authorization header&#10;     * @return Success or error response&#10;     */&#10;    @PostMapping(&quot;/logout&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; logout(HttpServletRequest request) {&#10;        String authHeader = request.getHeader(&quot;Authorization&quot;);&#10;&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(ApiResponse.error(&quot;No authorization token provided&quot;));&#10;        }&#10;&#10;        String jwt = authHeader.substring(7);&#10;        String username = jwtService.extractUsername(jwt);&#10;&#10;        if (username != null) {&#10;            // Blacklist the access token&#10;            tokenService.blacklistAccessToken(jwt);&#10;&#10;            logger.info(&quot;User {} successfully logged out&quot;, username);&#10;            return ResponseEntity.ok(ApiResponse.success(null, &quot;Successfully logged out&quot;));&#10;        }&#10;&#10;        return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                .body(ApiResponse.error(&quot;Invalid token&quot;));&#10;    }&#10;&#10;    /**&#10;     * Refresh access token using refresh token&#10;     *&#10;     * @param refreshTokenRequest The refresh token request&#10;     * @return New access token and refresh token&#10;     */&#10;    @PostMapping(&quot;/refresh-token&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoginResponse&gt;&gt; refreshToken(@RequestBody RefreshTokenRequest refreshTokenRequest) {&#10;        String refreshToken = refreshTokenRequest.getRefreshToken();&#10;&#10;        // Validate refresh token&#10;        String username = tokenService.validateRefreshToken(refreshToken);&#10;&#10;        if (username == null) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(ApiResponse.error(&quot;Invalid refresh token&quot;));&#10;        }&#10;&#10;        // Load user details and generate new tokens&#10;        UserDetails userDetails = userDetailsService.loadUserByUsername(username);&#10;&#10;        // Revoke old refresh token&#10;        tokenService.revokeRefreshToken(refreshToken);&#10;&#10;        // Generate new tokens&#10;        String newAccessToken = jwtService.generateAccessToken(userDetails);&#10;        String newRefreshToken = jwtService.generateRefreshToken(userDetails);&#10;&#10;        ApiResponse&lt;LoginResponse&gt; response = ApiResponse.success(&#10;                LoginResponse.builder()&#10;                        .accessToken(newAccessToken)&#10;                        .refreshToken(newRefreshToken)&#10;                        .verificationRequired(false)&#10;                        .build(),&#10;                &quot;Tokens refreshed successfully&quot;&#10;        );&#10;&#10;        logger.info(&quot;Tokens refreshed for user: {}&quot;, username);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/controller/robot/RobotCommandController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/controller/robot/RobotCommandController.java" />
              <option name="originalContent" value="package com.smartlab.zippy.controller.robot;&#10;&#10;import com.smartlab.zippy.model.dto.web.request.robot.LoadCommandRequest;&#10;import com.smartlab.zippy.model.dto.web.request.robot.MoveCommandRequest;&#10;import com.smartlab.zippy.model.dto.web.request.robot.PickupCommandRequest;&#10;import com.smartlab.zippy.model.dto.web.response.ApiResponse;&#10;import com.smartlab.zippy.model.dto.web.response.robot.LoadCommandResponse;&#10;import com.smartlab.zippy.model.dto.web.response.robot.MoveCommandResponse;&#10;import com.smartlab.zippy.model.dto.web.response.robot.PickupCommandResponse;&#10;import com.smartlab.zippy.model.dto.robot.RobotStatusDTO;&#10;import com.smartlab.zippy.model.dto.robot.RobotContainerStatusDTO;&#10;import com.smartlab.zippy.model.entity.Robot;&#10;import com.smartlab.zippy.model.entity.RobotContainer;&#10;import com.smartlab.zippy.repository.RobotRepository;&#10;import com.smartlab.zippy.repository.RobotContainerRepository;&#10;import com.smartlab.zippy.service.robot.RobotCommandService;&#10;import com.smartlab.zippy.service.robot.RobotDataService;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/robot/command&quot;)&#10;public class RobotCommandController {&#10;&#10;    private final RobotCommandService commandService;&#10;    private final RobotDataService robotDataService;&#10;    private final RobotRepository robotRepository;&#10;    private final RobotContainerRepository robotContainerRepository;&#10;&#10;    public RobotCommandController(RobotCommandService commandService,&#10;                                RobotDataService robotDataService,&#10;                                RobotRepository robotRepository,&#10;                                RobotContainerRepository robotContainerRepository) {&#10;        this.commandService = commandService;&#10;        this.robotDataService = robotDataService;&#10;        this.robotRepository = robotRepository;&#10;        this.robotContainerRepository = robotContainerRepository;&#10;    }&#10;&#10;    /**&#10;     * Request status from all robots and return free robots with free containers&#10;     * Flow: API call -&gt; Send command to all robots -&gt; Robots respond via status topic -&gt; Return free robots&#10;     *&#10;     * @return List of free robots with their container statuses&#10;     */&#10;    @PostMapping(&quot;/request-status&quot;)&#10;    @Transactional(readOnly = true)&#10;    public ResponseEntity&lt;ApiResponse&lt;Map&lt;String, Object&gt;&gt;&gt; requestStatusFromAllRobots() {&#10;        try {&#10;            // Get all robots from database&#10;            List&lt;Robot&gt; allRobots = (List&lt;Robot&gt;) robotRepository.findAll();&#10;            List&lt;String&gt; commandsSent = new ArrayList&lt;&gt;();&#10;&#10;            // Send status request command to each robot&#10;            for (Robot robot : allRobots) {&#10;                try {&#10;                    commandService.requestStatus(robot.getCode());&#10;                    commandsSent.add(robot.getCode());&#10;                } catch (Exception e) {&#10;                    // Log error but continue with other robots&#10;                    System.err.println(&quot;Failed to send status request to robot &quot; + robot.getCode() + &quot;: &quot; + e.getMessage());&#10;                }&#10;            }&#10;&#10;            // Wait a moment for robots to respond (robots will send data to status topic)&#10;            Thread.sleep(2000); // 2 seconds wait for responses&#10;&#10;            // Collect free robots and their container statuses&#10;            List&lt;Map&lt;String, Object&gt;&gt; freeRobots = new ArrayList&lt;&gt;();&#10;&#10;            for (Robot robot : allRobots) {&#10;                // Check if robot is online and get its status&#10;                if (robotDataService.isRobotOnline(robot.getCode())) {&#10;                    Optional&lt;RobotStatusDTO&gt; statusOpt = robotDataService.getStatus(robot.getCode());&#10;&#10;                    if (statusOpt.isPresent()) {&#10;                        RobotStatusDTO status = statusOpt.get();&#10;&#10;                        // Check if robot is free (assuming &quot;idle&quot; or &quot;free&quot; status means available)&#10;                        if (&quot;free&quot;.equalsIgnoreCase(status.getStatus())) {&#10;&#10;                            Map&lt;String, Object&gt; robotInfo = new HashMap&lt;&gt;();&#10;                            robotInfo.put(&quot;robotCode&quot;, robot.getCode());&#10;                            robotInfo.put(&quot;status&quot;, status.getStatus());&#10;                            robotInfo.put(&quot;online&quot;, true);&#10;&#10;                            // Get container statuses for this robot using repository query to avoid lazy loading&#10;                            List&lt;RobotContainer&gt; containers = robotContainerRepository.findByRobotCode(robot.getCode());&#10;                            List&lt;Map&lt;String, Object&gt;&gt; freeContainers = new ArrayList&lt;&gt;();&#10;&#10;                            for (RobotContainer container : containers) {&#10;                                Optional&lt;RobotContainerStatusDTO&gt; containerStatusOpt =&#10;                                    robotDataService.getContainerStatus(robot.getCode(), container.getContainerCode());&#10;&#10;                                if (containerStatusOpt.isPresent()) {&#10;                                    RobotContainerStatusDTO containerStatus = containerStatusOpt.get();&#10;&#10;                                    // Check if container is free&#10;                                    if (&quot;free&quot;.equalsIgnoreCase(containerStatus.getStatus())) {&#10;&#10;                                        Map&lt;String, Object&gt; containerInfo = new HashMap&lt;&gt;();&#10;                                        containerInfo.put(&quot;containerCode&quot;, container.getContainerCode());&#10;                                        containerInfo.put(&quot;status&quot;, containerStatus.getStatus());&#10;                                        freeContainers.add(containerInfo);&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            robotInfo.put(&quot;freeContainers&quot;, freeContainers);&#10;                            robotInfo.put(&quot;totalFreeContainers&quot;, freeContainers.size());&#10;&#10;                            // Only add robot if it has free containers or if we want all free robots&#10;                            if (!freeContainers.isEmpty()) {&#10;                                freeRobots.add(robotInfo);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Prepare response&#10;            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;            response.put(&quot;commandsSent&quot;, commandsSent.size());&#10;            response.put(&quot;robotsRequested&quot;, commandsSent);&#10;            response.put(&quot;freeRobotsCount&quot;, freeRobots.size());&#10;            response.put(&quot;freeRobots&quot;, freeRobots);&#10;            response.put(&quot;message&quot;, &quot;Status request sent to &quot; + commandsSent.size() + &quot; robots, found &quot; + freeRobots.size() + &quot; free robots&quot;);&#10;&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to request status from robots: &quot; + e.getMessage()&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send move command to robot&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param request Move command request&#10;     * @return Move command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/move&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;MoveCommandResponse&gt;&gt; move(&#10;            @PathVariable String robotCode,&#10;            @RequestBody MoveCommandRequest request&#10;    ) {&#10;        try {&#10;            commandService.sendMove(robotCode, request.getLat(), request.getLon(), request.getRoomCode());&#10;            MoveCommandResponse response = new MoveCommandResponse(&#10;                    robotCode,&#10;                    request.getLat(),&#10;                    request.getLon(),&#10;                    &quot;Move command sent successfully&quot;&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send move command to robot &quot; + robotCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send trip-based move command to robot&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param tripCode Trip Code&#10;     * @param request Move command request&#10;     * @return Move command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/trip/{tripCode}/move&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;MoveCommandResponse&gt;&gt; moveWithTrip(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String tripCode,&#10;            @RequestBody MoveCommandRequest request&#10;    ) {&#10;        try {&#10;            commandService.sendTripMove(robotCode, tripCode, request.getLat(), request.getLon(), request.getRoomCode());&#10;            MoveCommandResponse response = new MoveCommandResponse(&#10;                    robotCode,&#10;                    request.getLat(),&#10;                    request.getLon(),&#10;                    &quot;Trip move command sent successfully for trip: &quot; + tripCode&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send trip move command to robot &quot; + robotCode + &quot; for trip &quot; + tripCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send pickup command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param request Pickup command request&#10;     * @return Pickup command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/pickup&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PickupCommandResponse&gt;&gt; sendPickupCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @RequestBody PickupCommandRequest request) {&#10;        try {&#10;            commandService.sendPickup(robotCode, containerCode, request.isPickup());&#10;            PickupCommandResponse response = new PickupCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isPickup(),&#10;                    &quot;Pickup command sent successfully&quot;&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send pickup command to robot &quot; + robotCode + &quot; container &quot; + containerCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send trip-based pickup command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param tripCode Trip Code&#10;     * @param request Pickup command request&#10;     * @return Pickup command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/trip/{tripCode}/pickup&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PickupCommandResponse&gt;&gt; sendTripPickupCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @PathVariable String tripCode,&#10;            @RequestBody PickupCommandRequest request) {&#10;        try {&#10;            commandService.sendTripPickup(robotCode, containerCode, tripCode, request.isPickup());&#10;            PickupCommandResponse response = new PickupCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isPickup(),&#10;                    &quot;Trip pickup command sent successfully for trip: &quot; + tripCode&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send trip pickup command to robot &quot; + robotCode + &quot; container &quot; + containerCode + &quot; for trip &quot; + tripCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send load command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param request Load command request&#10;     * @return Load command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/load&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoadCommandResponse&gt;&gt; sendLoadCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @RequestBody LoadCommandRequest request) {&#10;        try {&#10;            commandService.sendLoad(robotCode, containerCode, request.isLoad());&#10;            LoadCommandResponse response = new LoadCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isLoad(),&#10;                    &quot;Load command sent successfully&quot;&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send load command to robot &quot; + robotCode + &quot; container &quot; + containerCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send trip-based load command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param tripCode Trip Code&#10;     * @param request Load command request&#10;     * @return Load command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/trip/{tripCode}/load&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoadCommandResponse&gt;&gt; sendTripLoadCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @PathVariable String tripCode,&#10;            @RequestBody LoadCommandRequest request) {&#10;        try {&#10;            commandService.sendTripLoad(robotCode, containerCode, tripCode, request.isLoad());&#10;            LoadCommandResponse response = new LoadCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isLoad(),&#10;                    &quot;Trip load command sent successfully for trip: &quot; + tripCode&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send trip load command to robot &quot; + robotCode + &quot; container &quot; + containerCode + &quot; for trip &quot; + tripCode&#10;            ));&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.controller.robot;&#10;&#10;import com.smartlab.zippy.model.dto.web.request.robot.LoadCommandRequest;&#10;import com.smartlab.zippy.model.dto.web.request.robot.MoveCommandRequest;&#10;import com.smartlab.zippy.model.dto.web.request.robot.PickupCommandRequest;&#10;import com.smartlab.zippy.model.dto.web.response.ApiResponse;&#10;import com.smartlab.zippy.model.dto.web.response.robot.LoadCommandResponse;&#10;import com.smartlab.zippy.model.dto.web.response.robot.MoveCommandResponse;&#10;import com.smartlab.zippy.model.dto.web.response.robot.PickupCommandResponse;&#10;import com.smartlab.zippy.model.dto.robot.RobotStatusDTO;&#10;import com.smartlab.zippy.model.dto.robot.RobotContainerStatusDTO;&#10;import com.smartlab.zippy.model.entity.Robot;&#10;import com.smartlab.zippy.model.entity.RobotContainer;&#10;import com.smartlab.zippy.model.entity.Trip;&#10;import com.smartlab.zippy.repository.RobotRepository;&#10;import com.smartlab.zippy.repository.RobotContainerRepository;&#10;import com.smartlab.zippy.repository.TripRepository;&#10;import com.smartlab.zippy.service.robot.RobotCommandService;&#10;import com.smartlab.zippy.service.robot.RobotDataService;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/robot/command&quot;)&#10;public class RobotCommandController {&#10;&#10;    private final RobotCommandService commandService;&#10;    private final RobotDataService robotDataService;&#10;    private final RobotRepository robotRepository;&#10;    private final RobotContainerRepository robotContainerRepository;&#10;    private final TripRepository tripRepository;&#10;&#10;    public RobotCommandController(RobotCommandService commandService,&#10;                                RobotDataService robotDataService,&#10;                                RobotRepository robotRepository,&#10;                                RobotContainerRepository robotContainerRepository,&#10;                                TripRepository tripRepository) {&#10;        this.commandService = commandService;&#10;        this.robotDataService = robotDataService;&#10;        this.robotRepository = robotRepository;&#10;        this.robotContainerRepository = robotContainerRepository;&#10;        this.tripRepository = tripRepository;&#10;    }&#10;&#10;    /**&#10;     * Request status from all robots and return free robots with free containers&#10;     * Flow: API call -&gt; Send command to all robots -&gt; Robots respond via status topic -&gt; Return free robots&#10;     *&#10;     * @return List of free robots with their container statuses&#10;     */&#10;    @PostMapping(&quot;/request-status&quot;)&#10;    @Transactional(readOnly = true)&#10;    public ResponseEntity&lt;ApiResponse&lt;Map&lt;String, Object&gt;&gt;&gt; requestStatusFromAllRobots() {&#10;        try {&#10;            // Get all robots from database&#10;            List&lt;Robot&gt; allRobots = (List&lt;Robot&gt;) robotRepository.findAll();&#10;            List&lt;String&gt; commandsSent = new ArrayList&lt;&gt;();&#10;&#10;            // Send status request command to each robot&#10;            for (Robot robot : allRobots) {&#10;                try {&#10;                    commandService.requestStatus(robot.getCode());&#10;                    commandsSent.add(robot.getCode());&#10;                } catch (Exception e) {&#10;                    // Log error but continue with other robots&#10;                    System.err.println(&quot;Failed to send status request to robot &quot; + robot.getCode() + &quot;: &quot; + e.getMessage());&#10;                }&#10;            }&#10;&#10;            // Wait a moment for robots to respond (robots will send data to status topic)&#10;            Thread.sleep(2000); // 2 seconds wait for responses&#10;&#10;            // Collect free robots and their container statuses&#10;            List&lt;Map&lt;String, Object&gt;&gt; freeRobots = new ArrayList&lt;&gt;();&#10;&#10;            for (Robot robot : allRobots) {&#10;                // Check if robot is online and get its status&#10;                if (robotDataService.isRobotOnline(robot.getCode())) {&#10;                    Optional&lt;RobotStatusDTO&gt; statusOpt = robotDataService.getStatus(robot.getCode());&#10;&#10;                    if (statusOpt.isPresent()) {&#10;                        RobotStatusDTO status = statusOpt.get();&#10;&#10;                        // Check if robot is free (assuming &quot;idle&quot; or &quot;free&quot; status means available)&#10;                        if (&quot;free&quot;.equalsIgnoreCase(status.getStatus())) {&#10;&#10;                            Map&lt;String, Object&gt; robotInfo = new HashMap&lt;&gt;();&#10;                            robotInfo.put(&quot;robotCode&quot;, robot.getCode());&#10;                            robotInfo.put(&quot;status&quot;, status.getStatus());&#10;                            robotInfo.put(&quot;online&quot;, true);&#10;&#10;                            // Get container statuses for this robot using repository query to avoid lazy loading&#10;                            List&lt;RobotContainer&gt; containers = robotContainerRepository.findByRobotCode(robot.getCode());&#10;                            List&lt;Map&lt;String, Object&gt;&gt; freeContainers = new ArrayList&lt;&gt;();&#10;&#10;                            for (RobotContainer container : containers) {&#10;                                Optional&lt;RobotContainerStatusDTO&gt; containerStatusOpt =&#10;                                    robotDataService.getContainerStatus(robot.getCode(), container.getContainerCode());&#10;&#10;                                if (containerStatusOpt.isPresent()) {&#10;                                    RobotContainerStatusDTO containerStatus = containerStatusOpt.get();&#10;&#10;                                    // Check if container is free&#10;                                    if (&quot;free&quot;.equalsIgnoreCase(containerStatus.getStatus())) {&#10;&#10;                                        Map&lt;String, Object&gt; containerInfo = new HashMap&lt;&gt;();&#10;                                        containerInfo.put(&quot;containerCode&quot;, container.getContainerCode());&#10;                                        containerInfo.put(&quot;status&quot;, containerStatus.getStatus());&#10;                                        freeContainers.add(containerInfo);&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            robotInfo.put(&quot;freeContainers&quot;, freeContainers);&#10;                            robotInfo.put(&quot;totalFreeContainers&quot;, freeContainers.size());&#10;&#10;                            // Only add robot if it has free containers or if we want all free robots&#10;                            if (!freeContainers.isEmpty()) {&#10;                                freeRobots.add(robotInfo);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Prepare response&#10;            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;            response.put(&quot;commandsSent&quot;, commandsSent.size());&#10;            response.put(&quot;robotsRequested&quot;, commandsSent);&#10;            response.put(&quot;freeRobotsCount&quot;, freeRobots.size());&#10;            response.put(&quot;freeRobots&quot;, freeRobots);&#10;            response.put(&quot;message&quot;, &quot;Status request sent to &quot; + commandsSent.size() + &quot; robots, found &quot; + freeRobots.size() + &quot; free robots&quot;);&#10;&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to request status from robots: &quot; + e.getMessage()&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send move command to robot&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param request Move command request&#10;     * @return Move command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/move&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;MoveCommandResponse&gt;&gt; move(&#10;            @PathVariable String robotCode,&#10;            @RequestBody MoveCommandRequest request&#10;    ) {&#10;        try {&#10;            commandService.sendMove(robotCode, request.getLat(), request.getLon(), request.getRoomCode());&#10;            MoveCommandResponse response = new MoveCommandResponse(&#10;                    robotCode,&#10;                    request.getLat(),&#10;                    request.getLon(),&#10;                    &quot;Move command sent successfully&quot;&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send move command to robot &quot; + robotCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send trip-based move command to robot&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param tripCode Trip Code&#10;     * @param request Move command request&#10;     * @return Move command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/trip/{tripCode}/move&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;MoveCommandResponse&gt;&gt; moveWithTrip(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String tripCode,&#10;            @RequestBody MoveCommandRequest request&#10;    ) {&#10;        try {&#10;            commandService.sendTripMove(robotCode, tripCode, request.getLat(), request.getLon(), request.getRoomCode());&#10;            MoveCommandResponse response = new MoveCommandResponse(&#10;                    robotCode,&#10;                    request.getLat(),&#10;                    request.getLon(),&#10;                    &quot;Trip move command sent successfully for trip: &quot; + tripCode&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send trip move command to robot &quot; + robotCode + &quot; for trip &quot; + tripCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send pickup command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param request Pickup command request&#10;     * @return Pickup command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/pickup&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PickupCommandResponse&gt;&gt; sendPickupCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @RequestBody PickupCommandRequest request) {&#10;        try {&#10;            commandService.sendPickup(robotCode, containerCode, request.isPickup());&#10;            PickupCommandResponse response = new PickupCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isPickup(),&#10;                    &quot;Pickup command sent successfully&quot;&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send pickup command to robot &quot; + robotCode + &quot; container &quot; + containerCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send trip-based pickup command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param tripCode Trip Code&#10;     * @param request Pickup command request&#10;     * @return Pickup command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/trip/{tripCode}/pickup&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PickupCommandResponse&gt;&gt; sendTripPickupCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @PathVariable String tripCode,&#10;            @RequestBody PickupCommandRequest request) {&#10;        try {&#10;            commandService.sendTripPickup(robotCode, containerCode, tripCode, request.isPickup());&#10;            PickupCommandResponse response = new PickupCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isPickup(),&#10;                    &quot;Trip pickup command sent successfully for trip: &quot; + tripCode&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send trip pickup command to robot &quot; + robotCode + &quot; container &quot; + containerCode + &quot; for trip &quot; + tripCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send load command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param request Load command request&#10;     * @return Load command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/load&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoadCommandResponse&gt;&gt; sendLoadCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @RequestBody LoadCommandRequest request) {&#10;        try {&#10;            commandService.sendLoad(robotCode, containerCode, request.isLoad());&#10;            LoadCommandResponse response = new LoadCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isLoad(),&#10;                    &quot;Load command sent successfully&quot;&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send load command to robot &quot; + robotCode + &quot; container &quot; + containerCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send trip-based load command to robot container&#10;     *&#10;     * @param robotCode Robot ID&#10;     * @param containerCode Container Code&#10;     * @param tripCode Trip Code&#10;     * @param request Load command request&#10;     * @return Load command response&#10;     */&#10;    @PostMapping(&quot;/{robotCode}/container/{containerCode}/trip/{tripCode}/load&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;LoadCommandResponse&gt;&gt; sendTripLoadCommand(&#10;            @PathVariable String robotCode,&#10;            @PathVariable String containerCode,&#10;            @PathVariable String tripCode,&#10;            @RequestBody LoadCommandRequest request) {&#10;        try {&#10;            commandService.sendTripLoad(robotCode, containerCode, tripCode, request.isLoad());&#10;            LoadCommandResponse response = new LoadCommandResponse(&#10;                    robotCode,&#10;                    containerCode,&#10;                    request.isLoad(),&#10;                    &quot;Trip load command sent successfully for trip: &quot; + tripCode&#10;            );&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse.error(&#10;                &quot;Failed to send trip load command to robot &quot; + robotCode + &quot; container &quot; + containerCode + &quot; for trip &quot; + tripCode&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check trip code validity&#10;     *&#10;     * @param tripCode Trip code to validate&#10;     * @return Trip validation status&#10;     */&#10;    @GetMapping(&quot;/trip/{tripCode}/check&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Map&lt;String, Object&gt;&gt;&gt; checkTripCode(@PathVariable String tripCode) {&#10;        try {&#10;            Optional&lt;Trip&gt; tripOptional = tripRepository.findByTripCode(tripCode);&#10;            &#10;            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;            &#10;            if (tripOptional.isPresent()) {&#10;                Trip trip = tripOptional.get();&#10;                response.put(&quot;valid&quot;, true);&#10;                response.put(&quot;tripCode&quot;, tripCode);&#10;                response.put(&quot;status&quot;, trip.getStatus());&#10;                response.put(&quot;startPoint&quot;, trip.getStartPoint());&#10;                response.put(&quot;endPoint&quot;, trip.getEndPoint());&#10;                response.put(&quot;robotId&quot;, trip.getRobotId());&#10;                response.put(&quot;userId&quot;, trip.getUserId());&#10;                &#10;                return ResponseEntity.ok(ApiResponse.success(response, &quot;Trip code is valid&quot;));&#10;            } else {&#10;                response.put(&quot;valid&quot;, false);&#10;                response.put(&quot;tripCode&quot;, tripCode);&#10;                response.put(&quot;message&quot;, &quot;Trip code not found&quot;);&#10;                &#10;                return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                        .body(ApiResponse.error(&quot;Trip code not found&quot;, response));&#10;            }&#10;        } catch (Exception e) {&#10;            Map&lt;String, Object&gt; errorResponse = new HashMap&lt;&gt;();&#10;            errorResponse.put(&quot;valid&quot;, false);&#10;            errorResponse.put(&quot;tripCode&quot;, tripCode);&#10;            errorResponse.put(&quot;error&quot;, e.getMessage());&#10;            &#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to validate trip code&quot;, errorResponse));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/dto/web/request/order/PickupVerifyOtpRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/dto/web/request/order/PickupVerifyOtpRequest.java" />
              <option name="originalContent" value="package com.smartlab.zippy.model.dto.web.request.order;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Pattern;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class PickupVerifyOtpRequest {&#10;    &#10;    @NotBlank(message = &quot;Order code is required&quot;)&#10;    private String orderCode;&#10;    &#10;    @NotBlank(message = &quot;OTP is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{6}$&quot;, message = &quot;OTP must be 6 digits&quot;)&#10;    private String otp;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.model.dto.web.request.order;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Pattern;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class PickupVerifyOtpRequest {&#10;    &#10;    @NotBlank(message = &quot;Order code is required&quot;)&#10;    private String orderCode;&#10;    &#10;    @NotBlank(message = &quot;OTP is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{6}$&quot;, message = &quot;OTP must be 6 digits&quot;)&#10;    private String otp;&#10;    &#10;    @NotBlank(message = &quot;Trip code is required&quot;)&#10;    private String tripCode;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/dto/web/response/trip/TripResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/dto/web/response/trip/TripResponse.java" />
              <option name="originalContent" value="package com.smartlab.zippy.model.dto.web.response.trip;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class TripResponse {&#10;    private UUID userId;&#10;    private UUID robotId;&#10;    private String robotCode;&#10;    private LocalDateTime startTime;&#10;    private LocalDateTime endTime;&#10;    private LocalDateTime startTime;&#10;    private LocalDateTime endTime;&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.model.dto.web.response.trip;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class TripResponse {&#10;    private UUID userId;&#10;    private UUID robotId;&#10;    private String robotCode;&#10;    private String tripCode;&#10;    private LocalDateTime startTime;&#10;    private LocalDateTime endTime;&#10;    private String status;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/entity/RobotContainer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/entity/RobotContainer.java" />
              <option name="originalContent" value="package com.smartlab.zippy.model.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;@Entity&#10;@Table(name = &quot;robot_container&quot;)&#10;public class RobotContainer {&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    &#10;    private UUID robotId;&#10;    @Column(name = &quot;container_code&quot;, unique = true)&#10;&#10;    &#10;    @JoinColumn(name = &quot;robot_id&quot;, insertable = false, updatable = false)&#10;    private Robot robot;&#10;    &#10;    @OneToMany(mappedBy = &quot;container&quot;, cascade = CascadeType.ALL)&#10;    private List&lt;Product&gt; products;&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.model.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import lombok.ToString;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Entity&#10;@Table(name = &quot;robot_container&quot;)&#10;@ToString(exclude = {&quot;robot&quot;, &quot;products&quot;}) // Exclude circular reference fields&#10;public class RobotContainer {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(name = &quot;robot_id&quot;)&#10;    private UUID robotId;&#10;&#10;    @Column(name = &quot;container_code&quot;, unique = true)&#10;    private String containerCode;&#10;&#10;    private String status;&#10;    &#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;robot_id&quot;, insertable = false, updatable = false)&#10;    private Robot robot;&#10;    &#10;    @OneToMany(mappedBy = &quot;container&quot;, cascade = CascadeType.ALL)&#10;    private List&lt;Product&gt; products;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/entity/Trip.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/model/entity/Trip.java" />
              <option name="originalContent" value="package com.smartlab.zippy.model.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Entity&#10;@Table(name = &quot;trip&quot;)&#10;public class Trip {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.UUID)&#10;    private UUID id;&#10;    &#10;    @Column(name = &quot;robot_id&quot;)&#10;    private UUID robotId;&#10;    &#10;    private String status;&#10;&#10;    @Column(name = &quot;start_time&quot;)&#10;    private LocalDateTime startTime;&#10;&#10;    @Column(name = &quot;end_time&quot;)&#10;    private LocalDateTime endTime;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;user_id&quot;, insertable = false, updatable = false)&#10;    private User user;&#10;    &#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;robot_id&quot;, insertable = false, updatable = false)&#10;    private Robot robot;&#10;    &#10;    @OneToMany(mappedBy = &quot;trip&quot;, cascade = CascadeType.ALL)&#10;    private List&lt;Order&gt; orders;&#10;    &#10;    @OneToMany(mappedBy = &quot;trip&quot;, cascade = CascadeType.ALL)&#10;    private List&lt;Product&gt; products;&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.model.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Entity&#10;@Table(name = &quot;trip&quot;)&#10;public class Trip {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.UUID)&#10;    private UUID id;&#10;    &#10;    @Column(name = &quot;trip_code&quot;, unique = true)&#10;    private String tripCode;&#10;&#10;    @Column(name = &quot;start_point&quot;)&#10;    private String startPoint;&#10;&#10;    @Column(name = &quot;end_point&quot;)&#10;    private String endPoint;&#10;    &#10;    @Column(name = &quot;user_id&quot;)&#10;    private UUID userId;&#10;    &#10;    @Column(name = &quot;robot_id&quot;)&#10;    private UUID robotId;&#10;    &#10;    private String status;&#10;&#10;    @Column(name = &quot;start_time&quot;)&#10;    private LocalDateTime startTime;&#10;&#10;    @Column(name = &quot;end_time&quot;)&#10;    private LocalDateTime endTime;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;user_id&quot;, insertable = false, updatable = false)&#10;    private User user;&#10;    &#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;robot_id&quot;, insertable = false, updatable = false)&#10;    private Robot robot;&#10;    &#10;    @OneToMany(mappedBy = &quot;trip&quot;, cascade = CascadeType.ALL)&#10;    private List&lt;Order&gt; orders;&#10;    &#10;    @OneToMany(mappedBy = &quot;trip&quot;, cascade = CascadeType.ALL)&#10;    private List&lt;Product&gt; products;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/repository/OrderRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/repository/OrderRepository.java" />
              <option name="originalContent" value="package com.smartlab.zippy.repository;&#10;&#10;import com.smartlab.zippy.model.entity.Order;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.CrudRepository;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;&#10;@Repository&#10;public interface OrderRepository extends CrudRepository&lt;Order, UUID&gt; {&#10;    List&lt;Order&gt; findByTripId(UUID tripId);&#10;    List&lt;Order&gt; findByStatus(String status);&#10;    Optional&lt;Order&gt; findByOrderCode(String orderCode);&#10;&#10;    @Query(&quot;SELECT o FROM Order o &quot; +&#10;           &quot;JOIN User u ON o.userId = u.id &quot; +&#10;           &quot;WHERE u.username = :username &quot; +&#10;           &quot;ORDER BY o.createdAt DESC&quot;)&#10;    List&lt;Order&gt; findByUsername(@Param(&quot;username&quot;) String username);&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.repository;&#10;&#10;import com.smartlab.zippy.model.entity.Order;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.CrudRepository;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;&#10;@Repository&#10;public interface OrderRepository extends CrudRepository&lt;Order, UUID&gt; {&#10;    List&lt;Order&gt; findByTripId(UUID tripId);&#10;    List&lt;Order&gt; findByStatus(String status);&#10;    Optional&lt;Order&gt; findByOrderCode(String orderCode);&#10;&#10;    @Query(&quot;SELECT o FROM Order o &quot; +&#10;           &quot;JOIN User u ON o.userId = u.id &quot; +&#10;           &quot;WHERE u.username = :username &quot; +&#10;           &quot;ORDER BY o.createdAt DESC&quot;)&#10;    List&lt;Order&gt; findByUsername(@Param(&quot;username&quot;) String username);&#10;&#10;    @Query(&quot;SELECT o FROM Order o &quot; +&#10;           &quot;JOIN o.trip t &quot; +&#10;           &quot;WHERE t.tripCode = :tripCode&quot;)&#10;    List&lt;Order&gt; findByTripCode(@Param(&quot;tripCode&quot;) String tripCode);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/repository/RobotContainerRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/repository/RobotContainerRepository.java" />
              <option name="originalContent" value="package com.smartlab.zippy.repository;&#10;&#10;import com.smartlab.zippy.model.entity.RobotContainer;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.CrudRepository;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;&#10;@Repository&#10;public interface RobotContainerRepository extends CrudRepository&lt;RobotContainer, Long&gt; {&#10;    List&lt;RobotContainer&gt; findByRobotId(UUID robotId);&#10;    List&lt;RobotContainer&gt; findByStatus(String status);&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.repository;&#10;&#10;import com.smartlab.zippy.model.entity.RobotContainer;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.CrudRepository;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;&#10;@Repository&#10;public interface RobotContainerRepository extends CrudRepository&lt;RobotContainer, Long&gt; {&#10;    List&lt;RobotContainer&gt; findByRobotId(UUID robotId);&#10;    List&lt;RobotContainer&gt; findByStatus(String status);&#10;    Optional&lt;RobotContainer&gt; findByContainerCode(String containerCode);&#10;&#10;    @Query(&quot;SELECT rc FROM RobotContainer rc JOIN rc.robot r WHERE r.code = :robotCode AND rc.containerCode = :containerCode&quot;)&#10;    Optional&lt;RobotContainer&gt; findByRobotCodeAndContainerCode(@Param(&quot;robotCode&quot;) String robotCode, @Param(&quot;containerCode&quot;) String containerCode);&#10;&#10;    @Query(&quot;SELECT rc FROM RobotContainer rc JOIN rc.robot r WHERE r.code = :robotCode&quot;)&#10;    List&lt;RobotContainer&gt; findByRobotCode(@Param(&quot;robotCode&quot;) String robotCode);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/auth/TokenService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/auth/TokenService.java" />
              <option name="originalContent" value="package com.smartlab.zippy.service.auth;&#10;&#10;import com.smartlab.zippy.config.JwtConfig;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.stereotype.Service;&#10;import java.util.UUID;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;@Service&#10;public class TokenService {&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(TokenService.class);&#10;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;&#10;    private final JwtConfig jwtConfig;&#10;&#10;    public TokenService(RedisTemplate&lt;String, Object&gt; redisTemplate, JwtConfig jwtConfig) {&#10;        this.redisTemplate = redisTemplate;&#10;        this.jwtConfig = jwtConfig;&#10;        // Verify Redis connectivity on startup&#10;        verifyRedisConnection();&#10;    }&#10;&#10;    /**&#10;     * Verify that Redis is connected and operational&#10;     */&#10;    private void verifyRedisConnection() {&#10;        try {&#10;            String testKey = &quot;test:connection&quot;;&#10;            String testValue = &quot;connected&quot;;&#10;&#10;            // Test set operation&#10;            log.info(&quot;Testing Redis connection by setting key: {}&quot;, testKey);&#10;            redisTemplate.opsForValue().set(testKey, testValue);&#10;&#10;            // Verify key exists after setting&#10;            Boolean keyExists = redisTemplate.hasKey(testKey);&#10;            log.info(&quot;Key exists check: {}&quot;, keyExists);&#10;&#10;            // Test get operation&#10;            String result = (String) redisTemplate.opsForValue().get(testKey);&#10;            log.info(&quot;Redis get test result: {}&quot;, result);&#10;&#10;            if (testValue.equals(result) &amp;&amp; Boolean.TRUE.equals(keyExists)) {&#10;                log.info(&quot;Redis connection verified successfully&quot;);&#10;            } else {&#10;                log.error(&quot;Redis connection test failed: value mismatch or key not found. Expected: {}, Got: {}, Key exists: {}&quot;,&#10;                          testValue, result, keyExists);&#10;            }&#10;&#10;            // Clean up test key&#10;            redisTemplate.delete(testKey);&#10;&#10;            // Double check key was deleted&#10;            Boolean keyStillExists = redisTemplate.hasKey(testKey);&#10;            log.info(&quot;Key deleted check: {}&quot;, !Boolean.TRUE.equals(keyStillExists));&#10;        } catch (Exception e) {&#10;            log.error(&quot;Redis connection verification failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Store a refresh token in Redis with username as a reference&#10;     * @param username The username associated with the token&#10;     * @return A UUID refresh token&#10;     */&#10;    public String generateRefreshToken(String username) {&#10;        String token = UUID.randomUUID().toString();&#10;        String key = JwtConfig.REFRESH_TOKEN_PREFIX + token;&#10;&#10;        try {&#10;            log.info(&quot;Storing refresh token in Redis with key: {}&quot;, key);&#10;&#10;            // Store username as the value with the refresh token as the key&#10;            redisTemplate.opsForValue().set(key, username);&#10;            redisTemplate.expire(key, jwtConfig.getRefreshTokenExpiration(), TimeUnit.MILLISECONDS);&#10;&#10;            // Verify the token was stored correctly&#10;            Boolean keyExists = redisTemplate.hasKey(key);&#10;            String storedUsername = (String) redisTemplate.opsForValue().get(key);&#10;&#10;            log.info(&quot;Verification - Key exists: {}, Retrieved username: {}&quot;, keyExists, storedUsername);&#10;&#10;            if (!Boolean.TRUE.equals(keyExists) || storedUsername == null) {&#10;                log.error(&quot;Failed to store refresh token in Redis - key exists: {}, value: {}&quot;, keyExists, storedUsername);&#10;            }&#10;&#10;            // Verify expiration was set&#10;            Long ttl = redisTemplate.getExpire(key, TimeUnit.MILLISECONDS);&#10;            log.info(&quot;Token expiration set to {} ms&quot;, ttl);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error storing refresh token in Redis: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return token;&#10;    }&#10;&#10;    /**&#10;     * Validate a refresh token from Redis&#10;     * @param token The refresh token to validate&#10;     * @return The username associated with the token or null if invalid&#10;     */&#10;    public String validateRefreshToken(String token) {&#10;        String key = JwtConfig.REFRESH_TOKEN_PREFIX + token;&#10;        try {&#10;            log.info(&quot;Validating refresh token with key: {}&quot;, key);&#10;&#10;            // Check if the key exists&#10;            Boolean keyExists = redisTemplate.hasKey(key);&#10;            log.info(&quot;Refresh token key exists: {}&quot;, keyExists);&#10;&#10;            if (Boolean.TRUE.equals(keyExists)) {&#10;                // Retrieve the expiration time&#10;                Long ttl = redisTemplate.getExpire(key, TimeUnit.MILLISECONDS);&#10;                log.info(&quot;Token TTL (Time To Live): {} ms&quot;, ttl);&#10;&#10;                if (ttl != null &amp;&amp; ttl &gt; 0) {&#10;                    // Token is valid and not expired&#10;                    String username = (String) redisTemplate.opsForValue().get(key);&#10;                    log.info(&quot;Validation result for token: value={}&quot;, username);&#10;                    return username;&#10;                } else {&#10;                    // Token has expired&#10;                    log.warn(&quot;Refresh token has expired: {}&quot;, key);&#10;                    return null;&#10;                }&#10;            } else {&#10;                log.warn(&quot;Refresh token not found in Redis: {}&quot;, key);&#10;                return null;&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error validating refresh token: {}&quot;, e.getMessage(), e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Revoke a refresh token&#10;     * @param token The refresh token to revoke&#10;     */&#10;    public void revokeRefreshToken(String token) {&#10;        String key = JwtConfig.REFRESH_TOKEN_PREFIX + token;&#10;        redisTemplate.delete(key);&#10;    }&#10;&#10;    /**&#10;     * Blacklist an access token&#10;     * @param token The JWT access token to blacklist&#10;     */&#10;    public void blacklistAccessToken(String token) {&#10;        String key = JwtConfig.BLACKLISTED_TOKEN_PREFIX + token;&#10;        redisTemplate.opsForValue().set(key, &quot;blacklisted&quot;);&#10;&#10;        // Set expiration to match the token's remaining lifetime&#10;        // Default to 15 minutes (900 seconds) if we can't determine the remaining time&#10;        redisTemplate.expire(key, 15 * 60, TimeUnit.SECONDS);&#10;    }&#10;&#10;    /**&#10;     * Check if an access token is blacklisted&#10;     * @param token The JWT access token to check&#10;     * @return true if the token is blacklisted, false otherwise&#10;     */&#10;    public boolean isAccessTokenBlacklisted(String token) {&#10;        String key = JwtConfig.BLACKLISTED_TOKEN_PREFIX + token;&#10;        return Boolean.TRUE.equals(redisTemplate.hasKey(key));&#10;    }&#10;&#10;    /**&#10;     * Revoke all tokens for a user by username&#10;     * To implement this properly with Redis, we would need to maintain a secondary&#10;     * index mapping usernames to their tokens&#10;     *&#10;     * @param username The username whose tokens should be revoked&#10;     */&#10;    public void revokeAllUserTokens(String username) {&#10;        // For a complete implementation, you would store a mapping of username -&gt; tokens&#10;        // and then iterate through and delete each one&#10;        // For now, this is a placeholder for that functionality&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.service.auth;&#10;&#10;import com.smartlab.zippy.config.JwtConfig;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.stereotype.Service;&#10;import java.util.UUID;&#10;import java.util.Set;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;@Service&#10;public class TokenService {&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(TokenService.class);&#10;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;&#10;    private final JwtConfig jwtConfig;&#10;    &#10;    // Constants for Redis keys&#10;    private static final String USER_TOKENS_PREFIX = &quot;user:tokens:&quot;;&#10;&#10;    public TokenService(RedisTemplate&lt;String, Object&gt; redisTemplate, JwtConfig jwtConfig) {&#10;        this.redisTemplate = redisTemplate;&#10;        this.jwtConfig = jwtConfig;&#10;        // Verify Redis connectivity on startup&#10;        verifyRedisConnection();&#10;    }&#10;&#10;    /**&#10;     * Verify that Redis is connected and operational&#10;     */&#10;    private void verifyRedisConnection() {&#10;        try {&#10;            String testKey = &quot;test:connection&quot;;&#10;            String testValue = &quot;connected&quot;;&#10;&#10;            // Test set operation&#10;            log.info(&quot;Testing Redis connection by setting key: {}&quot;, testKey);&#10;            redisTemplate.opsForValue().set(testKey, testValue);&#10;&#10;            // Verify key exists after setting&#10;            Boolean keyExists = redisTemplate.hasKey(testKey);&#10;            log.info(&quot;Key exists check: {}&quot;, keyExists);&#10;&#10;            // Test get operation&#10;            String result = (String) redisTemplate.opsForValue().get(testKey);&#10;            log.info(&quot;Redis get test result: {}&quot;, result);&#10;&#10;            if (testValue.equals(result) &amp;&amp; Boolean.TRUE.equals(keyExists)) {&#10;                log.info(&quot;Redis connection verified successfully&quot;);&#10;            } else {&#10;                log.error(&quot;Redis connection test failed: value mismatch or key not found. Expected: {}, Got: {}, Key exists: {}&quot;,&#10;                          testValue, result, keyExists);&#10;            }&#10;&#10;            // Clean up test key&#10;            redisTemplate.delete(testKey);&#10;&#10;            // Double check key was deleted&#10;            Boolean keyStillExists = redisTemplate.hasKey(testKey);&#10;            log.info(&quot;Key deleted check: {}&quot;, !Boolean.TRUE.equals(keyStillExists));&#10;        } catch (Exception e) {&#10;            log.error(&quot;Redis connection verification failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Store a refresh token in Redis with username as a reference&#10;     * @param username The username associated with the token&#10;     * @return A UUID refresh token&#10;     */&#10;    public String generateRefreshToken(String username) {&#10;        String token = UUID.randomUUID().toString();&#10;        String key = JwtConfig.REFRESH_TOKEN_PREFIX + token;&#10;        String userTokensKey = USER_TOKENS_PREFIX + username;&#10;&#10;        try {&#10;            log.info(&quot;Storing refresh token in Redis with key: {}&quot;, key);&#10;&#10;            // Store username as the value with the refresh token as the key&#10;            redisTemplate.opsForValue().set(key, username);&#10;            redisTemplate.expire(key, jwtConfig.getRefreshTokenExpiration(), TimeUnit.MILLISECONDS);&#10;&#10;            // Add token to user's token set for easy revocation&#10;            redisTemplate.opsForSet().add(userTokensKey, token);&#10;            redisTemplate.expire(userTokensKey, jwtConfig.getRefreshTokenExpiration(), TimeUnit.MILLISECONDS);&#10;&#10;            // Verify the token was stored correctly&#10;            Boolean keyExists = redisTemplate.hasKey(key);&#10;            String storedUsername = (String) redisTemplate.opsForValue().get(key);&#10;&#10;            log.info(&quot;Verification - Key exists: {}, Retrieved username: {}&quot;, keyExists, storedUsername);&#10;&#10;            if (!Boolean.TRUE.equals(keyExists) || storedUsername == null) {&#10;                log.error(&quot;Failed to store refresh token in Redis - key exists: {}, value: {}&quot;, keyExists, storedUsername);&#10;            }&#10;&#10;            // Verify expiration was set&#10;            Long ttl = redisTemplate.getExpire(key, TimeUnit.MILLISECONDS);&#10;            log.info(&quot;Token expiration set to {} ms&quot;, ttl);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error storing refresh token in Redis: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return token;&#10;    }&#10;&#10;    /**&#10;     * Validate a refresh token from Redis&#10;     * @param token The refresh token to validate&#10;     * @return The username associated with the token or null if invalid&#10;     */&#10;    public String validateRefreshToken(String token) {&#10;        String key = JwtConfig.REFRESH_TOKEN_PREFIX + token;&#10;        try {&#10;            log.info(&quot;Validating refresh token with key: {}&quot;, key);&#10;&#10;            // Check if the key exists&#10;            Boolean keyExists = redisTemplate.hasKey(key);&#10;            log.info(&quot;Refresh token key exists: {}&quot;, keyExists);&#10;&#10;            if (Boolean.TRUE.equals(keyExists)) {&#10;                // Retrieve the expiration time&#10;                Long ttl = redisTemplate.getExpire(key, TimeUnit.MILLISECONDS);&#10;                log.info(&quot;Token TTL (Time To Live): {} ms&quot;, ttl);&#10;&#10;                if (ttl != null &amp;&amp; ttl &gt; 0) {&#10;                    // Token is valid and not expired&#10;                    String username = (String) redisTemplate.opsForValue().get(key);&#10;                    log.info(&quot;Validation result for token: value={}&quot;, username);&#10;                    return username;&#10;                } else {&#10;                    // Token has expired&#10;                    log.warn(&quot;Refresh token has expired: {}&quot;, key);&#10;                    return null;&#10;                }&#10;            } else {&#10;                log.warn(&quot;Refresh token not found in Redis: {}&quot;, key);&#10;                return null;&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error validating refresh token: {}&quot;, e.getMessage(), e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Revoke a refresh token&#10;     * @param token The refresh token to revoke&#10;     */&#10;    public void revokeRefreshToken(String token) {&#10;        String key = JwtConfig.REFRESH_TOKEN_PREFIX + token;&#10;        &#10;        // Get username before deleting the token&#10;        String username = (String) redisTemplate.opsForValue().get(key);&#10;        &#10;        // Delete the token&#10;        redisTemplate.delete(key);&#10;        &#10;        // Remove token from user's token set&#10;        if (username != null) {&#10;            String userTokensKey = USER_TOKENS_PREFIX + username;&#10;            redisTemplate.opsForSet().remove(userTokensKey, token);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Blacklist an access token&#10;     * @param token The JWT access token to blacklist&#10;     */&#10;    public void blacklistAccessToken(String token) {&#10;        String key = JwtConfig.BLACKLISTED_TOKEN_PREFIX + token;&#10;        redisTemplate.opsForValue().set(key, &quot;blacklisted&quot;);&#10;&#10;        // Set expiration to match the token's remaining lifetime&#10;        // Default to 15 minutes (900 seconds) if we can't determine the remaining time&#10;        redisTemplate.expire(key, 15 * 60, TimeUnit.SECONDS);&#10;    }&#10;&#10;    /**&#10;     * Check if an access token is blacklisted&#10;     * @param token The JWT access token to check&#10;     * @return true if the token is blacklisted, false otherwise&#10;     */&#10;    public boolean isAccessTokenBlacklisted(String token) {&#10;        String key = JwtConfig.BLACKLISTED_TOKEN_PREFIX + token;&#10;        return Boolean.TRUE.equals(redisTemplate.hasKey(key));&#10;    }&#10;&#10;    /**&#10;     * Revoke all tokens for a user by username&#10;     * @param username The username whose tokens should be revoked&#10;     */&#10;    public void revokeAllUserTokens(String username) {&#10;        try {&#10;            String userTokensKey = USER_TOKENS_PREFIX + username;&#10;            &#10;            // Get all tokens for this user&#10;            Set&lt;Object&gt; userTokens = redisTemplate.opsForSet().members(userTokensKey);&#10;            &#10;            if (userTokens != null &amp;&amp; !userTokens.isEmpty()) {&#10;                log.info(&quot;Revoking {} tokens for user: {}&quot;, userTokens.size(), username);&#10;                &#10;                // Delete each token&#10;                for (Object tokenObj : userTokens) {&#10;                    String token = (String) tokenObj;&#10;                    String tokenKey = JwtConfig.REFRESH_TOKEN_PREFIX + token;&#10;                    redisTemplate.delete(tokenKey);&#10;                }&#10;                &#10;                // Delete the user's token set&#10;                redisTemplate.delete(userTokensKey);&#10;                &#10;                log.info(&quot;Successfully revoked all tokens for user: {}&quot;, username);&#10;            } else {&#10;                log.info(&quot;No tokens found for user: {}&quot;, username);&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error revoking all tokens for user {}: {}&quot;, username, e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/robot/RobotCommandService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/robot/RobotCommandService.java" />
              <option name="originalContent" value="package com.smartlab.zippy.service.robot;&#10;&#10;import com.smartlab.zippy.interfaces.MqttCommandPublisher;&#10;import org.springframework.stereotype.Service;&#10;&#10;@Service&#10;public class RobotCommandService {&#10;&#10;    private final MqttCommandPublisher publisher;&#10;&#10;    public RobotCommandService(MqttCommandPublisher publisher) {&#10;        this.publisher = publisher;&#10;    }&#10;&#10;    public void sendMove(String robotId, double lat, double lon, String roomCode) {&#10;        String topic = String.format(&quot;robot/%s/command/move&quot;, robotId);&#10;        String payload = String.format(&quot;{\&quot;lat\&quot;:%.6f,\&quot;lon\&quot;:%.6f,\&quot;roomCode\&quot;:\&quot;%s\&quot;}&quot;, lat, lon, roomCode);&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void sendPickup(String robotId, String containerCode, boolean pickup) {&#10;        String topic = String.format(&quot;robot/%s/container/%s/command/pickup&quot;, robotId, containerCode);&#10;        String payload = pickup ? &quot;1&quot; : &quot;0&quot;;&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void sendLoad(String robotId, String containerCode, boolean load) {&#10;        String topic = String.format(&quot;robot/%s/container/%s/command/load&quot;, robotId, containerCode);&#10;        String payload = load ? &quot;true&quot; : &quot;false&quot;;&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void requestStatus(String robotId) {&#10;        String topic = String.format(&quot;robot/%s/command/request-status&quot;, robotId);&#10;        String payload = &quot;{\&quot;action\&quot;:\&quot;request_status\&quot;}&quot;;&#10;        publisher.publish(payload, topic);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.service.robot;&#10;&#10;import com.smartlab.zippy.interfaces.MqttCommandPublisher;&#10;import org.springframework.stereotype.Service;&#10;&#10;@Service&#10;public class RobotCommandService {&#10;&#10;    private final MqttCommandPublisher publisher;&#10;&#10;    public RobotCommandService(MqttCommandPublisher publisher) {&#10;        this.publisher = publisher;&#10;    }&#10;&#10;    public void sendMove(String robotId, double lat, double lon, String roomCode) {&#10;        String topic = String.format(&quot;robot/%s/command/move&quot;, robotId);&#10;        String payload = String.format(&quot;{\&quot;lat\&quot;:%.6f,\&quot;lon\&quot;:%.6f,\&quot;roomCode\&quot;:\&quot;%s\&quot;}&quot;, lat, lon, roomCode);&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void sendPickup(String robotId, String containerCode, boolean pickup) {&#10;        String topic = String.format(&quot;robot/%s/container/%s/command/pickup&quot;, robotId, containerCode);&#10;        String payload = pickup ? &quot;1&quot; : &quot;0&quot;;&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void sendLoad(String robotId, String containerCode, boolean load) {&#10;        String topic = String.format(&quot;robot/%s/container/%s/command/load&quot;, robotId, containerCode);&#10;        String payload = load ? &quot;true&quot; : &quot;false&quot;;&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void requestStatus(String robotId) {&#10;        String topic = String.format(&quot;robot/%s/command/request-status&quot;, robotId);&#10;        String payload = &quot;{\&quot;action\&quot;:\&quot;request_status\&quot;}&quot;;&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    // Trip-based command methods&#10;    public void sendTripMove(String robotId, String tripCode, double lat, double lon, String roomCode) {&#10;        String topic = String.format(&quot;robot/%s/command/trip/%s/move&quot;, robotId, tripCode);&#10;        String payload = String.format(&quot;{\&quot;tripCode\&quot;:\&quot;%s\&quot;,\&quot;lat\&quot;:%.6f,\&quot;lon\&quot;:%.6f,\&quot;roomCode\&quot;:\&quot;%s\&quot;}&quot;, tripCode, lat, lon, roomCode);&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void sendTripPickup(String robotId, String containerCode, String tripCode, boolean pickup) {&#10;        String topic = String.format(&quot;robot/%s/container/%s/command/trip/%s/pickup&quot;, robotId, containerCode, tripCode);&#10;        String payload = String.format(&quot;{\&quot;tripCode\&quot;:\&quot;%s\&quot;,\&quot;pickup\&quot;:%s}&quot;, tripCode, pickup ? &quot;true&quot; : &quot;false&quot;);&#10;        publisher.publish(payload, topic);&#10;    }&#10;&#10;    public void sendTripLoad(String robotId, String containerCode, String tripCode, boolean load) {&#10;        String topic = String.format(&quot;robot/%s/container/%s/command/trip/%s/load&quot;, robotId, containerCode, tripCode);&#10;        String payload = String.format(&quot;{\&quot;tripCode\&quot;:\&quot;%s\&quot;,\&quot;load\&quot;:%s}&quot;, tripCode, load ? &quot;true&quot; : &quot;false&quot;);&#10;        publisher.publish(payload, topic);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/trip/TripCodeGenerator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/trip/TripCodeGenerator.java" />
              <option name="updatedContent" value="package com.smartlab.zippy.service.trip;&#10;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.security.SecureRandom;&#10;&#10;@Service&#10;public class TripCodeGenerator {&#10;    &#10;    private static final String PREFIX = &quot;T-&quot;;&#10;    private static final int CODE_LENGTH = 6;&#10;    private static final SecureRandom random = new SecureRandom();&#10;    &#10;    public String generateTripCode() {&#10;        StringBuilder codeBuilder = new StringBuilder(PREFIX);&#10;        &#10;        for (int i = 0; i &lt; CODE_LENGTH; i++) {&#10;            codeBuilder.append(random.nextInt(10));&#10;        }&#10;        &#10;        return codeBuilder.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>