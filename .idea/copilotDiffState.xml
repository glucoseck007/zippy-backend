<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/controller/payment/PaymentController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/controller/payment/PaymentController.java" />
              <option name="originalContent" value="package com.smartlab.zippy.controller.payment;&#10;&#10;import com.smartlab.zippy.model.dto.web.response.ApiResponse;&#10;import com.smartlab.zippy.model.dto.web.response.payment.PaymentDTO;&#10;import com.smartlab.zippy.model.dto.web.response.payment.PaymentLinkResponse;&#10;import com.smartlab.zippy.model.entity.Order;&#10;import com.smartlab.zippy.model.entity.Payment;&#10;import com.smartlab.zippy.service.payment.PayOSService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.*;&#10;&#10;@Slf4j&#10;@RestController&#10;@RequestMapping(&quot;/api/payment&quot;)&#10;@RequiredArgsConstructor&#10;public class PaymentController {&#10;&#10;    private final PayOSService payOSService;&#10;&#10;    /**&#10;     * Create a payment link for an order&#10;     * @param orderId The ID of the order to create a payment for&#10;     * @return Payment link information including checkout URL&#10;     */&#10;    @PostMapping(&quot;/create/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; createPayment(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Creating payment for order ID: {}&quot;, orderId);&#10;            PaymentLinkResponse response = payOSService.createPaymentLink(orderId);&#10;&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(response, &quot;Payment link created successfully&quot;)&#10;            );&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error creating payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to create payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Webhook endpoint for PayOS to notify about payment status changes&#10;     * @param payload The payload sent by PayOS&#10;     * @return Success response if webhook processed successfully&#10;     */&#10;    @PostMapping(&quot;/webhook&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;String&gt;&gt; paymentWebhook(@RequestBody Map&lt;String, Object&gt; payload) {&#10;        try {&#10;            log.info(&quot;Received payment webhook: {}&quot;, payload);&#10;&#10;            // Extract payment ID from the payload&#10;            if (payload.containsKey(&quot;paymentLinkId&quot;)) {&#10;                String paymentLinkId = payload.get(&quot;paymentLinkId&quot;).toString();&#10;                boolean verified = payOSService.verifyPayment(paymentLinkId);&#10;&#10;                if (verified) {&#10;                    return ResponseEntity.ok(&#10;                            ApiResponse.success(&quot;Payment verified successfully&quot;)&#10;                    );&#10;                } else {&#10;                    return ResponseEntity.ok(&#10;                            ApiResponse.success(&quot;Payment verification pending&quot;)&#10;                    );&#10;                }&#10;            }&#10;&#10;            return ResponseEntity.badRequest()&#10;                    .body(ApiResponse.error(&quot;Invalid webhook payload&quot;));&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error processing payment webhook: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to process payment webhook: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Endpoint to manually verify a payment status&#10;     * @param paymentLinkId The payment link ID from PayOS&#10;     * @return Success response if payment verified&#10;     */&#10;    @GetMapping(&quot;/verify/{paymentLinkId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;String&gt;&gt; verifyPayment(@PathVariable String paymentLinkId) {&#10;        try {&#10;            log.info(&quot;Manually verifying payment: {}&quot;, paymentLinkId);&#10;            boolean verified = payOSService.verifyPayment(paymentLinkId);&#10;&#10;            if (verified) {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.success(&quot;Payment verified successfully&quot;)&#10;                );&#10;            } else {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.error(&quot;Payment verification failed&quot;)&#10;                );&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error verifying payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to verify payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a payment link for a mobile app&#10;     * @param orderId The ID of the order to create a payment for&#10;     * @return Payment link information including checkout URL&#10;     */&#10;    @PostMapping(&quot;/mobile/create/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; createMobilePayment(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Creating mobile payment for order ID: {}&quot;, orderId);&#10;            PaymentLinkResponse response = payOSService.createPaymentLinkForMobile(orderId);&#10;&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(response, &quot;Mobile payment link created successfully&quot;)&#10;            );&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error creating mobile payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to create mobile payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Endpoint for mobile clients to check payment status after redirection&#10;     * @param orderId The order ID to verify payment for&#10;     * @return Status of the payment&#10;     */&#10;    @GetMapping(&quot;/mobile/status/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Map&lt;String, Object&gt;&gt;&gt; getMobilePaymentStatus(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Checking payment status for order ID: {}&quot;, orderId);&#10;&#10;            // Use the new getPaymentStatus method that calls PayOS API&#10;            Map&lt;String, Object&gt; response = payOSService.getPaymentStatus(orderId);&#10;&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error checking payment status: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to check payment status: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cancel a payment for an order&#10;     * @param orderId The ID of the order to cancel payment for&#10;     * @return Success response if payment was cancelled successfully&#10;     */&#10;    @DeleteMapping(&quot;/mobile/cancel/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;String&gt;&gt; cancelMobilePayment(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Cancelling payment for order ID: {}&quot;, orderId);&#10;            boolean cancelled = payOSService.cancelPayment(orderId);&#10;&#10;            if (cancelled) {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.success(&quot;Payment cancelled successfully&quot;)&#10;                );&#10;            } else {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.error(&quot;No payment found to cancel or cancellation failed&quot;)&#10;                );&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error cancelling payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to cancel payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get existing payment link for an order or create a new one&#10;     * @param orderId The ID of the order&#10;     * @param forceNew If true, will cancel any existing payment and create a new one&#10;     * @return Payment link information including checkout URL&#10;     */&#10;    @PostMapping(&quot;/mobile/create/{orderId}/force-new&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; createMobilePaymentForceNew(&#10;            @PathVariable UUID orderId,&#10;            @RequestParam(defaultValue = &quot;true&quot;) boolean forceNew) {&#10;        try {&#10;            log.info(&quot;Creating mobile payment for order ID: {}, forceNew: {}&quot;, orderId, forceNew);&#10;            PaymentLinkResponse response = payOSService.createPaymentLinkForMobile(orderId, forceNew);&#10;&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(response, &quot;Mobile payment link created successfully&quot;)&#10;            );&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error creating mobile payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to create mobile payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get existing payment link for an order without creating a new one if it exists&#10;     * @param orderId The ID of the order&#10;     * @return Existing payment link information or error if none exists&#10;     */&#10;    @GetMapping(&quot;/mobile/get/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; getMobilePaymentLink(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Getting existing payment link for order ID: {}&quot;, orderId);&#10;            PaymentLinkResponse response = payOSService.getExistingPaymentLink(orderId);&#10;&#10;            if (response != null) {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.success(response, &quot;Existing payment link retrieved successfully&quot;)&#10;                );&#10;            } else {&#10;                return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                        .body(ApiResponse.error(&quot;No existing payment link found for this order&quot;));&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error getting payment link: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to get payment link: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.controller.payment;&#10;&#10;import com.smartlab.zippy.model.dto.web.response.ApiResponse;&#10;import com.smartlab.zippy.model.dto.web.response.payment.PaymentDTO;&#10;import com.smartlab.zippy.model.dto.web.response.payment.PaymentLinkResponse;&#10;import com.smartlab.zippy.model.entity.Order;&#10;import com.smartlab.zippy.model.entity.Payment;&#10;import com.smartlab.zippy.service.payment.PayOSService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.*;&#10;&#10;@Slf4j&#10;@RestController&#10;@RequestMapping(&quot;/api/payment&quot;)&#10;@RequiredArgsConstructor&#10;public class PaymentController {&#10;&#10;    private final PayOSService payOSService;&#10;&#10;    /**&#10;     * Create a payment link for an order&#10;     * @param orderId The ID of the order to create a payment for&#10;     * @return Payment link information including checkout URL&#10;     */&#10;    @PostMapping(&quot;/create/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; createPayment(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Creating payment for order ID: {}&quot;, orderId);&#10;            PaymentLinkResponse response = payOSService.createPaymentLink(orderId);&#10;&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(response, &quot;Payment link created successfully&quot;)&#10;            );&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error creating payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to create payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Webhook endpoint for PayOS to notify about payment status changes&#10;     * @param payload The payload sent by PayOS&#10;     * @return Success response if webhook processed successfully&#10;     */&#10;    @PostMapping(&quot;/webhook&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;String&gt;&gt; paymentWebhook(@RequestBody Map&lt;String, Object&gt; payload) {&#10;        try {&#10;            log.info(&quot;Received payment webhook: {}&quot;, payload);&#10;&#10;            // Extract payment ID from the payload&#10;            if (payload.containsKey(&quot;paymentLinkId&quot;)) {&#10;                String paymentLinkId = payload.get(&quot;paymentLinkId&quot;).toString();&#10;                boolean verified = payOSService.verifyPayment(paymentLinkId);&#10;&#10;                if (verified) {&#10;                    return ResponseEntity.ok(&#10;                            ApiResponse.success(&quot;Payment verified successfully&quot;)&#10;                    );&#10;                } else {&#10;                    return ResponseEntity.ok(&#10;                            ApiResponse.success(&quot;Payment verification pending&quot;)&#10;                    );&#10;                }&#10;            }&#10;&#10;            return ResponseEntity.badRequest()&#10;                    .body(ApiResponse.error(&quot;Invalid webhook payload&quot;));&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error processing payment webhook: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to process payment webhook: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Endpoint to manually verify a payment status&#10;     * @param paymentLinkId The payment link ID from PayOS&#10;     * @return Success response if payment verified&#10;     */&#10;    @GetMapping(&quot;/verify/{paymentLinkId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;String&gt;&gt; verifyPayment(@PathVariable String paymentLinkId) {&#10;        try {&#10;            log.info(&quot;Manually verifying payment: {}&quot;, paymentLinkId);&#10;            boolean verified = payOSService.verifyPayment(paymentLinkId);&#10;&#10;            if (verified) {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.success(&quot;Payment verified successfully&quot;)&#10;                );&#10;            } else {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.error(&quot;Payment verification failed&quot;)&#10;                );&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error verifying payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to verify payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a payment link for a mobile app&#10;     * @param orderId The ID of the order to create a payment for&#10;     * @return Payment link information including checkout URL&#10;     */&#10;    @PostMapping(&quot;/mobile/create/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; createMobilePayment(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Creating mobile payment for order ID: {}&quot;, orderId);&#10;            PaymentLinkResponse response = payOSService.createPaymentLinkForMobile(orderId);&#10;&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(response, &quot;Mobile payment link created successfully&quot;)&#10;            );&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error creating mobile payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to create mobile payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Endpoint for mobile clients to check payment status after redirection&#10;     * @param orderId The order ID to verify payment for&#10;     * @return Status of the payment&#10;     */&#10;    @GetMapping(&quot;/mobile/status/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Map&lt;String, Object&gt;&gt;&gt; getMobilePaymentStatus(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Checking payment status for order ID: {}&quot;, orderId);&#10;&#10;            // Use the new getPaymentStatus method that calls PayOS API&#10;            Map&lt;String, Object&gt; response = payOSService.getPaymentStatus(orderId);&#10;&#10;            return ResponseEntity.ok(ApiResponse.success(response));&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error checking payment status: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to check payment status: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cancel a payment for an order&#10;     * @param orderId The ID of the order to cancel payment for&#10;     * @return Success response if payment was cancelled successfully&#10;     */&#10;    @DeleteMapping(&quot;/mobile/cancel/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;String&gt;&gt; cancelMobilePayment(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Cancelling payment for order ID: {}&quot;, orderId);&#10;            boolean cancelled = payOSService.cancelPayment(orderId);&#10;&#10;            if (cancelled) {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.success(&quot;Payment cancelled successfully&quot;)&#10;                );&#10;            } else {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.error(&quot;No payment found to cancel or cancellation failed&quot;)&#10;                );&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error cancelling payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to cancel payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get existing payment link for an order or create a new one&#10;     * @param orderId The ID of the order&#10;     * @param forceNew If true, will cancel any existing payment and create a new one&#10;     * @return Payment link information including checkout URL&#10;     */&#10;    @PostMapping(&quot;/mobile/create/{orderId}/force-new&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; createMobilePaymentForceNew(&#10;            @PathVariable UUID orderId,&#10;            @RequestParam(defaultValue = &quot;true&quot;) boolean forceNew) {&#10;        try {&#10;            log.info(&quot;Creating mobile payment for order ID: {}, forceNew: {}&quot;, orderId, forceNew);&#10;            PaymentLinkResponse response = payOSService.createPaymentLinkForMobile(orderId, forceNew);&#10;&#10;            return ResponseEntity.ok(&#10;                    ApiResponse.success(response, &quot;Mobile payment link created successfully&quot;)&#10;            );&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error creating mobile payment: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to create mobile payment: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get existing payment link for an order without creating a new one if it exists&#10;     * @param orderId The ID of the order&#10;     * @return Existing payment link information or error if none exists&#10;     */&#10;    @GetMapping(&quot;/mobile/get/{orderId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;PaymentLinkResponse&gt;&gt; getMobilePaymentLink(@PathVariable UUID orderId) {&#10;        try {&#10;            log.info(&quot;Getting existing payment link for order ID: {}&quot;, orderId);&#10;            PaymentLinkResponse response = payOSService.getExistingPaymentLink(orderId);&#10;&#10;            if (response != null) {&#10;                return ResponseEntity.ok(&#10;                        ApiResponse.success(response, &quot;Existing payment link retrieved successfully&quot;)&#10;                );&#10;            } else {&#10;                return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                        .body(ApiResponse.error(&quot;No existing payment link found for this order&quot;));&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error getting payment link: {}&quot;, e.getMessage(), e);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(ApiResponse.error(&quot;Failed to get payment link: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/repository/PaymentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/repository/PaymentRepository.java" />
              <option name="originalContent" value="package com.smartlab.zippy.repository;&#10;&#10;import com.smartlab.zippy.model.entity.Payment;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.CrudRepository;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;&#10;@Repository&#10;public interface PaymentRepository extends CrudRepository&lt;Payment, UUID&gt; {&#10;    List&lt;Payment&gt; findByUserId(UUID userId);&#10;    List&lt;Payment&gt; findByOrderId(UUID orderId);&#10;    Optional&lt;Payment&gt; findByProviderTransactionId(String providerTransactionId);&#10;    Optional&lt;Payment&gt; findByPaymentCode(Long paymentCode);&#10;&#10;    @Query(&quot;SELECT p FROM Payment p LEFT JOIN FETCH p.order LEFT JOIN FETCH p.user WHERE p.orderId = :orderId&quot;)&#10;    List&lt;Payment&gt; findByOrderIdWithDetails(@Param(&quot;orderId&quot;) UUID orderId);&#10;&#10;    @Query(&quot;SELECT p FROM Payment p LEFT JOIN FETCH p.order LEFT JOIN FETCH p.user WHERE p.providerTransactionId = :providerTransactionId&quot;)&#10;    Optional&lt;Payment&gt; findByProviderTransactionIdWithDetails(@Param(&quot;providerTransactionId&quot;) String providerTransactionId);&#10;    &#10;    @Query(&quot;SELECT p FROM Payment p LEFT JOIN FETCH p.order LEFT JOIN FETCH p.user WHERE p.paymentCode = :paymentCode&quot;)&#10;    Optional&lt;Payment&gt; findByPaymentCodeWithDetails(@Param(&quot;paymentCode&quot;) String paymentCode);&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.repository;&#10;&#10;import com.smartlab.zippy.model.entity.Payment;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.CrudRepository;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;&#10;@Repository&#10;public interface PaymentRepository extends CrudRepository&lt;Payment, UUID&gt; {&#10;    List&lt;Payment&gt; findByUserId(UUID userId);&#10;    List&lt;Payment&gt; findByOrderId(UUID orderId);&#10;    Optional&lt;Payment&gt; findByProviderTransactionId(String providerTransactionId);&#10;    Optional&lt;Payment&gt; findByPaymentCode(Long paymentCode);&#10;&#10;    @Query(&quot;SELECT p FROM Payment p LEFT JOIN FETCH p.order LEFT JOIN FETCH p.user WHERE p.orderId = :orderId&quot;)&#10;    List&lt;Payment&gt; findByOrderIdWithDetails(@Param(&quot;orderId&quot;) UUID orderId);&#10;&#10;    @Query(&quot;SELECT p FROM Payment p LEFT JOIN FETCH p.order LEFT JOIN FETCH p.user WHERE p.providerTransactionId = :providerTransactionId&quot;)&#10;    Optional&lt;Payment&gt; findByProviderTransactionIdWithDetails(@Param(&quot;providerTransactionId&quot;) String providerTransactionId);&#10;    &#10;    @Query(&quot;SELECT p FROM Payment p LEFT JOIN FETCH p.order LEFT JOIN FETCH p.user WHERE p.paymentCode = :paymentCode&quot;)&#10;    Optional&lt;Payment&gt; findByPaymentCodeWithDetails(@Param(&quot;paymentCode&quot;) String paymentCode);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/order/OrderService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/smartlab/zippy/service/order/OrderService.java" />
              <option name="originalContent" value="package com.smartlab.zippy.service.order;&#10;&#10;import com.smartlab.zippy.model.dto.web.request.order.BatchOrderRequest;&#10;import com.smartlab.zippy.model.dto.web.request.order.OrderRequest;&#10;import com.smartlab.zippy.model.dto.web.response.order.OrderResponse;&#10;import com.smartlab.zippy.model.dto.robot.RobotContainerStatusDTO;&#10;import com.smartlab.zippy.model.dto.robot.RobotStatusDTO;&#10;import com.smartlab.zippy.model.entity.Order;&#10;import com.smartlab.zippy.model.entity.Product;&#10;import com.smartlab.zippy.model.entity.Robot;&#10;import com.smartlab.zippy.model.entity.Trip;&#10;import com.smartlab.zippy.model.entity.User;&#10;import com.smartlab.zippy.repository.OrderRepository;&#10;import com.smartlab.zippy.repository.ProductRepository;&#10;import com.smartlab.zippy.repository.RobotContainerRepository;&#10;import com.smartlab.zippy.repository.RobotRepository;&#10;import com.smartlab.zippy.repository.TripRepository;&#10;import com.smartlab.zippy.repository.UserRepository;&#10;import com.smartlab.zippy.service.robot.RobotDataService;&#10;import com.smartlab.zippy.service.trip.TripCodeGenerator;&#10;import com.smartlab.zippy.service.trip.TripStatusService;&#10;import com.smartlab.zippy.service.qr.QRCodeService;&#10;import com.smartlab.zippy.interfaces.MqttCommandPublisher;&#10;import com.smartlab.zippy.model.dto.web.response.qr.QRCodeResponse;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class OrderService {&#10;&#10;    private final OrderRepository orderRepository;&#10;    private final ProductRepository productRepository;&#10;    private final TripRepository tripRepository;&#10;    private final RobotContainerRepository robotContainerRepository;&#10;    private final RobotRepository robotRepository;&#10;    private final UserRepository userRepository;&#10;    private final RobotDataService robotDataService;&#10;    private final TripCodeGenerator tripCodeGenerator;&#10;    private final OrderCodeGenerator orderCodeGenerator;&#10;    private final QRCodeService qrCodeService;&#10;    private final MqttCommandPublisher mqttCommandPublisher;&#10;    private final TripStatusService tripStatusService;&#10;&#10;    @Transactional&#10;    public OrderResponse createOrder(OrderRequest request) {&#10;        log.info(&quot;Creating order from sender: {} to receiver: {}, product: {}, robot: {}&quot;,&#10;                request.getSenderIdentifier(), request.getReceiverIdentifier(), request.getProductName(), request.getRobotCode());&#10;&#10;        // Find sender by email or phone to get userId&#10;        User sender = findUserByIdentifier(request.getSenderIdentifier())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Sender not found with identifier: &quot; + request.getSenderIdentifier()));&#10;&#10;        // Find receiver by email or phone to get receiverId&#10;        User receiver = findUserByIdentifier(request.getReceiverIdentifier())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Receiver not found with identifier: &quot; + request.getReceiverIdentifier()));&#10;&#10;        // Validate robot is online and free using cached data&#10;        validateRobotAvailability(request.getRobotCode(), request.getRobotContainerCode());&#10;&#10;        // Create or find active trip for the robot (now includes robot container ID)&#10;        Trip trip = findOrCreateActiveTrip(request.getRobotCode(), request.getRobotContainerCode(), request.getStartPoint(), request.getEndpoint(), sender.getId());&#10;&#10;        // Create new product with auto-generated ID&#10;        Product product = Product.builder()&#10;                .code(request.getProductName()) // Use product name as code&#10;                .tripId(trip.getId())&#10;                .containerCode(request.getRobotContainerCode())&#10;                .build();&#10;&#10;        Product savedProduct = productRepository.save(product);&#10;&#10;        // Generate unique order code&#10;        String orderCode = orderCodeGenerator.generateOrderCode();&#10;&#10;        // Create order with both sender and receiver IDs&#10;        Order order = Order.builder()&#10;                .orderCode(orderCode)&#10;                .userId(sender.getId()) // Sender ID&#10;                .receiverId(receiver.getId()) // Receiver ID&#10;                .tripId(trip.getId())&#10;                .productId(savedProduct.getId()) // Use the auto-generated product ID&#10;                .price(BigDecimal.ZERO) // Default price, can be calculated based on business logic&#10;                .status(&quot;PENDING&quot;)&#10;                .createdAt(LocalDateTime.now())&#10;                .build();&#10;&#10;        Order savedOrder = orderRepository.save(order);&#10;&#10;        // Build response with usernames from retrieved User objects&#10;        return OrderResponse.builder()&#10;                .orderId(savedOrder.getId())&#10;                .orderCode(savedOrder.getOrderCode())&#10;                .senderUsername(sender.getUsername())&#10;                .receiverUsername(receiver.getUsername())&#10;                .productName(savedProduct.getCode()) // Use product code from saved product&#10;                .robotCode(request.getRobotCode())&#10;                .robotContainerCode(request.getRobotContainerCode())&#10;                .endpoint(request.getEndpoint())&#10;                .price(savedOrder.getPrice())&#10;                .status(savedOrder.getStatus())&#10;                .createdAt(savedOrder.getCreatedAt())&#10;                .completedAt(savedOrder.getCompletedAt())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Create multiple orders for different receivers in a single batch&#10;     * This optimizes the case where one user wants to send to multiple recipients&#10;     */&#10;    @Transactional&#10;    public List&lt;OrderResponse&gt; createBatchOrders(BatchOrderRequest request) {&#10;        log.info(&quot;Creating batch orders from sender: {} to {} recipients&quot;,&#10;                request.getSenderIdentifier(), request.getRecipients().size());&#10;&#10;        // Find sender by identifier (email or phone) to get userId&#10;        User sender = findUserByIdentifier(request.getSenderIdentifier())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Sender not found with identifier: &quot; + request.getSenderIdentifier()));&#10;&#10;        // Validate all receivers exist before creating any orders&#10;        List&lt;User&gt; receivers = new ArrayList&lt;&gt;();&#10;        for (BatchOrderRequest.OrderRecipient recipient : request.getRecipients()) {&#10;            User receiver = findUserByIdentifier(recipient.getReceiverIdentifier())&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;Receiver not found with identifier: &quot; + recipient.getReceiverIdentifier()));&#10;            receivers.add(receiver);&#10;        }&#10;&#10;        // Validate robot is online and free using cached data&#10;        validateRobotAvailability(request.getRobotCode(), request.getRobotContainerCode());&#10;&#10;        // Create or find active trip for the robot (shared trip for all orders)&#10;        Trip trip = findOrCreateActiveTrip(request.getRobotCode(), request.getRobotContainerCode(),&#10;                                         request.getStartPoint(), request.getEndpoint(), sender.getId());&#10;&#10;        List&lt;OrderResponse&gt; responses = new ArrayList&lt;&gt;();&#10;&#10;        // Create orders for each recipient&#10;        for (int i = 0; i &lt; request.getRecipients().size(); i++) {&#10;            BatchOrderRequest.OrderRecipient recipient = request.getRecipients().get(i);&#10;            User receiver = receivers.get(i);&#10;&#10;            // Create product for this order&#10;            Product product = Product.builder()&#10;                    .code(recipient.getProductName())&#10;                    .tripId(trip.getId())&#10;                    .containerCode(request.getRobotContainerCode())&#10;                    .build();&#10;&#10;            Product savedProduct = productRepository.save(product);&#10;&#10;            // Generate unique order code&#10;            String orderCode = orderCodeGenerator.generateOrderCode();&#10;&#10;            // Create order&#10;            Order order = Order.builder()&#10;                    .orderCode(orderCode)&#10;                    .userId(sender.getId())&#10;                    .receiverId(receiver.getId())&#10;                    .tripId(trip.getId())&#10;                    .productId(savedProduct.getId())&#10;                    .price(BigDecimal.ZERO)&#10;                    .status(&quot;PENDING&quot;)&#10;                    .createdAt(LocalDateTime.now())&#10;                    .build();&#10;&#10;            Order savedOrder = orderRepository.save(order);&#10;&#10;            // Build response with usernames from retrieved User objects&#10;            OrderResponse response = OrderResponse.builder()&#10;                    .orderId(savedOrder.getId())&#10;                    .orderCode(savedOrder.getOrderCode())&#10;                    .senderUsername(sender.getUsername())&#10;                    .receiverUsername(receiver.getUsername())&#10;                    .productName(savedProduct.getCode())&#10;                    .robotCode(request.getRobotCode())&#10;                    .robotContainerCode(request.getRobotContainerCode())&#10;                    .endpoint(request.getEndpoint())&#10;                    .price(savedOrder.getPrice())&#10;                    .status(savedOrder.getStatus())&#10;                    .createdAt(savedOrder.getCreatedAt())&#10;                    .completedAt(savedOrder.getCompletedAt())&#10;                    .build();&#10;&#10;            responses.add(response);&#10;        }&#10;&#10;        log.info(&quot;Successfully created {} orders in batch for sender: {}&quot;, responses.size(), request.getSenderIdentifier());&#10;        return responses;&#10;    }&#10;&#10;    /**&#10;     * Find user by email, phone number, or username&#10;     * This method supports flexible user identification using email, phone, or username&#10;     */&#10;    private Optional&lt;User&gt; findUserByIdentifier(String identifier) {&#10;        if (identifier == null || identifier.trim().isEmpty()) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        identifier = identifier.trim();&#10;&#10;        // Check if identifier looks like an email (contains @)&#10;        if (identifier.contains(&quot;@&quot;)) {&#10;            log.debug(&quot;Looking up user by email: {}&quot;, identifier);&#10;            return userRepository.findByEmail(identifier);&#10;        } else {&#10;            // First try to find by phone&#10;            log.debug(&quot;Looking up user by phone: {}&quot;, identifier);&#10;            Optional&lt;User&gt; userByPhone = userRepository.findByPhone(identifier);&#10;&#10;            // If not found by phone, try by username&#10;            if (userByPhone.isEmpty()) {&#10;                log.debug(&quot;Not found by phone, looking up user by username: {}&quot;, identifier);&#10;                return userRepository.findByUsername(identifier);&#10;            }&#10;&#10;            return userByPhone;&#10;        }&#10;    }&#10;&#10;    private void validateRobotAvailability(String robotCode, String robotContainerCode) {&#10;        // Check if robot is online using cached data&#10;        if (!robotDataService.isRobotOnline(robotCode)) {&#10;            throw new RuntimeException(&quot;Robot &quot; + robotCode + &quot; is not online&quot;);&#10;        }&#10;&#10;        // Check robot status using cached data&#10;        Optional&lt;RobotStatusDTO&gt; robotStatusOpt = robotDataService.getStatus(robotCode);&#10;        if (robotStatusOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Robot &quot; + robotCode + &quot; status not available&quot;);&#10;        }&#10;&#10;        RobotStatusDTO robotStatus = robotStatusOpt.get();&#10;        if (!&quot;free&quot;.equalsIgnoreCase(robotStatus.getStatus())) {&#10;            throw new RuntimeException(&quot;Robot &quot; + robotCode + &quot; is not available (status: &quot; + robotStatus.getStatus() + &quot;)&quot;);&#10;        }&#10;&#10;        // Check container status using cached data&#10;        Optional&lt;RobotContainerStatusDTO&gt; containerStatusOpt =&#10;                robotDataService.getContainerStatus(robotCode, robotContainerCode);&#10;        if (containerStatusOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Container &quot; + robotContainerCode + &quot; status not available for robot &quot; + robotCode);&#10;        }&#10;&#10;        RobotContainerStatusDTO containerStatus = containerStatusOpt.get();&#10;        if (!&quot;free&quot;.equalsIgnoreCase(containerStatus.getStatus())) {&#10;            throw new RuntimeException(&quot;Container &quot; + robotContainerCode + &quot; is not available (status: &quot; + containerStatus.getStatus() + &quot;)&quot;);&#10;        }&#10;&#10;        log.info(&quot;Robot {} and container {} are available for order&quot;, robotCode, robotContainerCode);&#10;    }&#10;&#10;    private Trip findOrCreateActiveTrip(String robotCode, String robotContainerCode, String startPoint, String endpoint, UUID userId) {&#10;        // Look for an active trip for the robot code - uses JOIN query to avoid lazy loading issues&#10;        Optional&lt;Trip&gt; activeTrip = tripRepository.findActiveByRobotCode(robotCode);&#10;&#10;        if (activeTrip.isPresent()) {&#10;            Trip existingTrip = activeTrip.get();&#10;            // Update trip with start point, endpoint, user ID, and robot container ID if not already set&#10;            if (existingTrip.getStartPoint() == null || existingTrip.getEndPoint() == null ||&#10;                existingTrip.getUserId() == null || existingTrip.getRobotContainerId() == null) {&#10;&#10;                if (existingTrip.getStartPoint() == null) {&#10;                    existingTrip.setStartPoint(startPoint);&#10;                }&#10;                if (existingTrip.getEndPoint() == null) {&#10;                    existingTrip.setEndPoint(endpoint);&#10;                }&#10;                if (existingTrip.getUserId() == null) {&#10;                    existingTrip.setUserId(userId);&#10;                }&#10;&#10;                // Get and set robot container ID if not already set&#10;                if (existingTrip.getRobotContainerId() == null) {&#10;                    Long robotContainerId = getRobotContainerIdByCode(robotCode, robotContainerCode);&#10;                    existingTrip.setRobotContainerId(robotContainerId);&#10;                }&#10;&#10;                return tripRepository.save(existingTrip);&#10;            }&#10;            return existingTrip;&#10;        }&#10;&#10;        // For new trip creation, we need the actual robot UUID and container ID from database&#10;        UUID robotId = getRobotIdByCode(robotCode);&#10;        Long robotContainerId = getRobotContainerIdByCode(robotCode, robotContainerCode);&#10;&#10;        // Generate unique trip code&#10;        String tripCode = tripCodeGenerator.generateTripCode();&#10;&#10;        // Create new trip if no active trip exists - starts with PENDING status&#10;        Trip newTrip = Trip.builder()&#10;                .tripCode(tripCode)&#10;                .robotId(robotId)&#10;                .robotContainerId(robotContainerId)&#10;                .userId(userId)&#10;                .startPoint(startPoint)&#10;                .endPoint(endpoint)&#10;                .status(&quot;PENDING&quot;) // Trip starts as PENDING, becomes ACTIVE when robot receives move command&#10;                .startTime(LocalDateTime.now())&#10;                .build();&#10;&#10;        return tripRepository.save(newTrip);&#10;    }&#10;&#10;    private UUID getRobotIdByCode(String robotCode) {&#10;        // Minimal database query to get robot UUID for trip creation only&#10;        // The availability checking was already done using cached data&#10;        Robot robot = robotRepository.findByCode(robotCode)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Robot not found with code: &quot; + robotCode));&#10;        return robot.getId();&#10;    }&#10;&#10;    private Long getRobotContainerIdByCode(String robotCode, String robotContainerCode) {&#10;        // Get robot container ID for trip creation&#10;        return robotContainerRepository.findByRobotCodeAndContainerCode(robotCode, robotContainerCode)&#10;                .map(robotContainer -&gt; robotContainer.getId())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Robot container not found with robot code: &quot; + robotCode + &quot; and container code: &quot; + robotContainerCode));&#10;    }&#10;&#10;    public List&lt;OrderResponse&gt; getAllOrders() {&#10;        log.info(&quot;Retrieving all orders&quot;);&#10;&#10;        Iterable&lt;Order&gt; orderIterable = orderRepository.findAll();&#10;        List&lt;Order&gt; orders = new ArrayList&lt;&gt;();&#10;        orderIterable.forEach(orders::add);&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;OrderResponse&gt; getOrdersByUsername(String username) {&#10;        log.info(&quot;Retrieving orders for username: {}&quot;, username);&#10;&#10;        List&lt;Order&gt; orders = orderRepository.findByUsername(username);&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get orders where the user is the sender&#10;     */&#10;    public List&lt;OrderResponse&gt; getOrdersBySender(String senderUsername) {&#10;        log.info(&quot;Retrieving orders sent by: {}&quot;, senderUsername);&#10;&#10;        User sender = userRepository.findByUsername(senderUsername)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Sender not found with username: &quot; + senderUsername));&#10;&#10;        List&lt;Order&gt; orders = orderRepository.findByUserId(sender.getId());&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get orders where the user is the receiver&#10;     */&#10;    public List&lt;OrderResponse&gt; getOrdersByReceiver(String receiverUsername) {&#10;        log.info(&quot;Retrieving orders received by: {}&quot;, receiverUsername);&#10;&#10;        User receiver = userRepository.findByUsername(receiverUsername)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Receiver not found with username: &quot; + receiverUsername));&#10;&#10;        List&lt;Order&gt; orders = orderRepository.findByReceiverId(receiver.getId());&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get order by order code&#10;     * @param orderCode Order code to search for&#10;     * @return OrderResponse containing order details including price&#10;     */&#10;    public OrderResponse getOrderByOrderCode(String orderCode) {&#10;        log.info(&quot;Retrieving order by order code: {}&quot;, orderCode);&#10;&#10;        Optional&lt;Order&gt; orderOpt = orderRepository.findByOrderCode(orderCode);&#10;        if (orderOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Order not found with code: &quot; + orderCode);&#10;        }&#10;&#10;        Order order = orderOpt.get();&#10;        return convertToOrderResponse(order);&#10;    }&#10;&#10;    private OrderResponse convertToOrderResponse(Order order) {&#10;        // Get product information from product table using product ID&#10;        String productName = &quot;N/A&quot;;&#10;        String robotContainerCode = &quot;N/A&quot;;&#10;        if (order.getProductId() != null) {&#10;            Optional&lt;Product&gt; product = productRepository.findById(order.getProductId());&#10;            if (product.isPresent()) {&#10;                productName = product.get().getCode(); // Using product code as product name&#10;                robotContainerCode = product.get().getContainerCode();&#10;            }&#10;        }&#10;&#10;        // Get robot code, start point, and endpoint from trip information&#10;        String robotCode = &quot;N/A&quot;;&#10;        String startPoint = &quot;N/A&quot;;&#10;        String endpoint = &quot;N/A&quot;;&#10;        if (order.getTripId() != null) {&#10;            Optional&lt;Trip&gt; trip = tripRepository.findById(order.getTripId());&#10;            if (trip.isPresent()) {&#10;                startPoint = trip.get().getStartPoint();&#10;                endpoint = trip.get().getEndPoint();&#10;                // Get robot code from robot table using robot ID&#10;                if (trip.get().getRobotId() != null) {&#10;                    Optional&lt;Robot&gt; robot = robotRepository.findById(trip.get().getRobotId());&#10;                    if (robot.isPresent()) {&#10;                        robotCode = robot.get().getCode();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Get sender and receiver usernames&#10;        String senderUsername = &quot;N/A&quot;;&#10;        String receiverUsername = &quot;N/A&quot;;&#10;&#10;        if (order.getUserId() != null) {&#10;            Optional&lt;User&gt; sender = userRepository.findById(order.getUserId());&#10;            if (sender.isPresent()) {&#10;                senderUsername = sender.get().getUsername();&#10;            }&#10;        }&#10;&#10;        if (order.getReceiverId() != null) {&#10;            Optional&lt;User&gt; receiver = userRepository.findById(order.getReceiverId());&#10;            if (receiver.isPresent()) {&#10;                receiverUsername = receiver.get().getUsername();&#10;            }&#10;        }&#10;&#10;        return OrderResponse.builder()&#10;                .orderId(order.getId())&#10;                .orderCode(order.getOrderCode())&#10;                .senderUsername(senderUsername)&#10;                .receiverUsername(receiverUsername)&#10;                .productName(productName) // Product name from product table&#10;                .robotCode(robotCode) // Robot code from robot table via trip&#10;                .robotContainerCode(robotContainerCode) // Container code from product table&#10;                .startPoint(startPoint) // Start point from trip table&#10;                .endpoint(endpoint) // Endpoint from trip table&#10;                .price(order.getPrice())&#10;                .status(order.getStatus())&#10;                .createdAt(order.getCreatedAt())&#10;                .completedAt(order.getCompletedAt())&#10;                .build();&#10;    }&#10;&#10;    public QRCodeResponse generateAndSendQRCode(String orderCode) {&#10;        log.info(&quot;Generating QR code for orderCode: {}&quot;, orderCode);&#10;&#10;        // Find the order by order code&#10;        Optional&lt;Order&gt; orderOpt = orderRepository.findByOrderCode(orderCode);&#10;        if (orderOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Order not found with code: &quot; + orderCode);&#10;        }&#10;&#10;        Order order = orderOpt.get();&#10;&#10;        // Get trip information to find robot code&#10;        String robotCode = &quot;N/A&quot;;&#10;        String tripCode = &quot;N/A&quot;;&#10;        if (order.getTripId() != null) {&#10;            Optional&lt;Trip&gt; trip = tripRepository.findById(order.getTripId());&#10;            if (trip.isPresent()) {&#10;                tripCode = trip.get().getTripCode();&#10;                if (trip.get().getRobotId() != null) {&#10;                    Optional&lt;Robot&gt; robot = robotRepository.findById(trip.get().getRobotId());&#10;                    if (robot.isPresent()) {&#10;                        robotCode = robot.get().getCode();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create QR code data (JSON format with order and trip information)&#10;        String qrData = String.format(&#10;            &quot;{\&quot;orderCode\&quot;:\&quot;%s\&quot;,\&quot;tripCode\&quot;:\&quot;%s\&quot;,\&quot;timestamp\&quot;:\&quot;%s\&quot;}&quot;,&#10;            orderCode, tripCode, LocalDateTime.now()&#10;        );&#10;&#10;        // Generate QR code&#10;        String qrCodeBase64 = qrCodeService.generateQRCode(qrData);&#10;&#10;        // Send QR code to robot via MQTT&#10;        String mqttTopic = String.format(&quot;robot/%s/command/qr&quot;, robotCode);&#10;        String mqttPayload = String.format(&#10;            &quot;{\&quot;orderCode\&quot;:\&quot;%s\&quot;,\&quot;tripCode\&quot;:\&quot;%s\&quot;,\&quot;qrCode\&quot;:\&quot;%s\&quot;}&quot;,&#10;            orderCode, tripCode, qrCodeBase64&#10;        );&#10;&#10;        try {&#10;            mqttCommandPublisher.publish(mqttPayload, mqttTopic);&#10;            log.info(&quot;QR code sent to robot {} via MQTT topic: {}&quot;, robotCode, mqttTopic);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to send QR code to robot {}: {}&quot;, robotCode, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Failed to send QR code to robot&quot;, e);&#10;        }&#10;&#10;        return QRCodeResponse.builder()&#10;                .orderCode(orderCode)&#10;                .qrCodeBase64(qrCodeBase64)&#10;                .robotCode(robotCode)&#10;                .message(&quot;QR code generated and sent to robot successfully&quot;)&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Verify OTP and complete order&#10;     * Sets order status to FINISHED and trip status to COMPLETED&#10;     * @param orderCode Order code to verify&#10;     * @param otp OTP to verify&#10;     */&#10;    @Transactional&#10;    public void verifyOTPAndCompleteOrder(String orderCode, String otp) {&#10;        log.info(&quot;Verifying OTP for orderCode: {}&quot;, orderCode);&#10;&#10;        // Find the order by order code&#10;        Optional&lt;Order&gt; orderOpt = orderRepository.findByOrderCode(orderCode);&#10;        if (orderOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Order not found with code: &quot; + orderCode);&#10;        }&#10;&#10;        Order order = orderOpt.get();&#10;&#10;        // TODO: Implement actual OTP verification logic here&#10;        // For now, accepting any non-empty OTP as valid&#10;        boolean isOtpValid = otp != null &amp;&amp; !otp.trim().isEmpty();&#10;&#10;        if (!isOtpValid) {&#10;            throw new RuntimeException(&quot;Invalid OTP provided&quot;);&#10;        }&#10;&#10;        // Update order status to FINISHED and set completion time&#10;        order.setStatus(&quot;FINISHED&quot;);&#10;        order.setCompletedAt(LocalDateTime.now());&#10;        orderRepository.save(order);&#10;        log.info(&quot;Order {} status set to FINISHED&quot;, orderCode);&#10;&#10;        // Update trip status to COMPLETED using TripStatusService&#10;        if (order.getTripId() != null) {&#10;            Optional&lt;Trip&gt; tripOpt = tripRepository.findById(order.getTripId());&#10;            if (tripOpt.isPresent()) {&#10;                Trip trip = tripOpt.get();&#10;                String tripCode = trip.getTripCode();&#10;                if (tripCode != null) {&#10;                    tripStatusService.completeTripByOtpVerification(tripCode);&#10;                    log.info(&quot;Trip {} status set to COMPLETED via TripStatusService&quot;, tripCode);&#10;                } else {&#10;                    log.warn(&quot;Trip code is null for trip ID: {}&quot;, trip.getId());&#10;                }&#10;            } else {&#10;                log.warn(&quot;Trip not found for order: {}&quot;, orderCode);&#10;            }&#10;        } else {&#10;            log.warn(&quot;No trip associated with order: {}&quot;, orderCode);&#10;        }&#10;&#10;        log.info(&quot;Successfully completed OTP verification for order {} and associated trip&quot;, orderCode);&#10;    }&#10;&#10;&#10;    public boolean approveOrder(String orderCode) {&#10;        log.info(&quot;Approving order with orderCode: {}&quot;, orderCode);&#10;        if (orderRepository.findByOrderCode(orderCode).isPresent()) {&#10;            // Update order status to APPROVED&#10;            Order order = orderRepository.findByOrderCode(orderCode).get();&#10;            order.setStatus(&quot;APPROVED&quot;);&#10;            orderRepository.save(order);&#10;            log.info(&quot;Order {} approved successfully&quot;, orderCode);&#10;            return true;&#10;        } else {&#10;            log.warn(&quot;Order with code {} not found for approval&quot;, orderCode);&#10;            return false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.smartlab.zippy.service.order;&#10;&#10;import com.smartlab.zippy.model.dto.web.request.order.BatchOrderRequest;&#10;import com.smartlab.zippy.model.dto.web.request.order.OrderRequest;&#10;import com.smartlab.zippy.model.dto.web.response.order.OrderResponse;&#10;import com.smartlab.zippy.model.dto.robot.RobotContainerStatusDTO;&#10;import com.smartlab.zippy.model.dto.robot.RobotStatusDTO;&#10;import com.smartlab.zippy.model.entity.Order;&#10;import com.smartlab.zippy.model.entity.Product;&#10;import com.smartlab.zippy.model.entity.Robot;&#10;import com.smartlab.zippy.model.entity.Trip;&#10;import com.smartlab.zippy.model.entity.User;&#10;import com.smartlab.zippy.repository.OrderRepository;&#10;import com.smartlab.zippy.repository.ProductRepository;&#10;import com.smartlab.zippy.repository.RobotContainerRepository;&#10;import com.smartlab.zippy.repository.RobotRepository;&#10;import com.smartlab.zippy.repository.TripRepository;&#10;import com.smartlab.zippy.repository.UserRepository;&#10;import com.smartlab.zippy.service.robot.RobotDataService;&#10;import com.smartlab.zippy.service.trip.TripCodeGenerator;&#10;import com.smartlab.zippy.service.trip.TripStatusService;&#10;import com.smartlab.zippy.service.qr.QRCodeService;&#10;import com.smartlab.zippy.interfaces.MqttCommandPublisher;&#10;import com.smartlab.zippy.model.dto.web.response.qr.QRCodeResponse;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class OrderService {&#10;&#10;    private final OrderRepository orderRepository;&#10;    private final ProductRepository productRepository;&#10;    private final TripRepository tripRepository;&#10;    private final RobotContainerRepository robotContainerRepository;&#10;    private final RobotRepository robotRepository;&#10;    private final UserRepository userRepository;&#10;    private final RobotDataService robotDataService;&#10;    private final TripCodeGenerator tripCodeGenerator;&#10;    private final OrderCodeGenerator orderCodeGenerator;&#10;    private final QRCodeService qrCodeService;&#10;    private final MqttCommandPublisher mqttCommandPublisher;&#10;    private final TripStatusService tripStatusService;&#10;&#10;    @Transactional&#10;    public OrderResponse createOrder(OrderRequest request) {&#10;        log.info(&quot;Creating order from sender: {} to receiver: {}, product: {}, robot: {}&quot;,&#10;                request.getSenderIdentifier(), request.getReceiverIdentifier(), request.getProductName(), request.getRobotCode());&#10;&#10;        // Find sender by email or phone to get userId&#10;        User sender = findUserByIdentifier(request.getSenderIdentifier())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Sender not found with identifier: &quot; + request.getSenderIdentifier()));&#10;&#10;        // Find receiver by email or phone to get receiverId&#10;        User receiver = findUserByIdentifier(request.getReceiverIdentifier())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Receiver not found with identifier: &quot; + request.getReceiverIdentifier()));&#10;&#10;        // Validate robot is online and free using cached data&#10;        validateRobotAvailability(request.getRobotCode(), request.getRobotContainerCode());&#10;&#10;        // Create or find active trip for the robot (now includes robot container ID)&#10;        Trip trip = findOrCreateActiveTrip(request.getRobotCode(), request.getRobotContainerCode(), request.getStartPoint(), request.getEndpoint(), sender.getId());&#10;&#10;        // Create new product with auto-generated ID&#10;        Product product = Product.builder()&#10;                .code(request.getProductName()) // Use product name as code&#10;                .tripId(trip.getId())&#10;                .containerCode(request.getRobotContainerCode())&#10;                .build();&#10;&#10;        Product savedProduct = productRepository.save(product);&#10;&#10;        // Generate unique order code&#10;        String orderCode = orderCodeGenerator.generateOrderCode();&#10;&#10;        // Create order with both sender and receiver IDs&#10;        Order order = Order.builder()&#10;                .orderCode(orderCode)&#10;                .userId(sender.getId()) // Sender ID&#10;                .receiverId(receiver.getId()) // Receiver ID&#10;                .tripId(trip.getId())&#10;                .productId(savedProduct.getId()) // Use the auto-generated product ID&#10;                .price(BigDecimal.ZERO) // Default price, can be calculated based on business logic&#10;                .status(&quot;PENDING&quot;)&#10;                .createdAt(LocalDateTime.now())&#10;                .build();&#10;&#10;        Order savedOrder = orderRepository.save(order);&#10;&#10;        // Build response with usernames from retrieved User objects&#10;        return OrderResponse.builder()&#10;                .orderId(savedOrder.getId())&#10;                .orderCode(savedOrder.getOrderCode())&#10;                .senderUsername(sender.getUsername())&#10;                .receiverUsername(receiver.getUsername())&#10;                .productName(savedProduct.getCode()) // Use product code from saved product&#10;                .robotCode(request.getRobotCode())&#10;                .robotContainerCode(request.getRobotContainerCode())&#10;                .endpoint(request.getEndpoint())&#10;                .price(savedOrder.getPrice())&#10;                .status(savedOrder.getStatus())&#10;                .createdAt(savedOrder.getCreatedAt())&#10;                .completedAt(savedOrder.getCompletedAt())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Create multiple orders for different receivers in a single batch&#10;     * This optimizes the case where one user wants to send to multiple recipients&#10;     */&#10;    @Transactional&#10;    public List&lt;OrderResponse&gt; createBatchOrders(BatchOrderRequest request) {&#10;        log.info(&quot;Creating batch orders from sender: {} to {} recipients&quot;,&#10;                request.getSenderIdentifier(), request.getRecipients().size());&#10;&#10;        // Find sender by identifier (email or phone) to get userId&#10;        User sender = findUserByIdentifier(request.getSenderIdentifier())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Sender not found with identifier: &quot; + request.getSenderIdentifier()));&#10;&#10;        // Validate all receivers exist before creating any orders&#10;        List&lt;User&gt; receivers = new ArrayList&lt;&gt;();&#10;        for (BatchOrderRequest.OrderRecipient recipient : request.getRecipients()) {&#10;            User receiver = findUserByIdentifier(recipient.getReceiverIdentifier())&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;Receiver not found with identifier: &quot; + recipient.getReceiverIdentifier()));&#10;            receivers.add(receiver);&#10;        }&#10;&#10;        // Validate robot is online and free using cached data&#10;        validateRobotAvailability(request.getRobotCode(), request.getRobotContainerCode());&#10;&#10;        // Create or find active trip for the robot (shared trip for all orders)&#10;        Trip trip = findOrCreateActiveTrip(request.getRobotCode(), request.getRobotContainerCode(),&#10;                                         request.getStartPoint(), request.getEndpoint(), sender.getId());&#10;&#10;        List&lt;OrderResponse&gt; responses = new ArrayList&lt;&gt;();&#10;&#10;        // Create orders for each recipient&#10;        for (int i = 0; i &lt; request.getRecipients().size(); i++) {&#10;            BatchOrderRequest.OrderRecipient recipient = request.getRecipients().get(i);&#10;            User receiver = receivers.get(i);&#10;&#10;            // Create product for this order&#10;            Product product = Product.builder()&#10;                    .code(recipient.getProductName())&#10;                    .tripId(trip.getId())&#10;                    .containerCode(request.getRobotContainerCode())&#10;                    .build();&#10;&#10;            Product savedProduct = productRepository.save(product);&#10;&#10;            // Generate unique order code&#10;            String orderCode = orderCodeGenerator.generateOrderCode();&#10;&#10;            // Create order&#10;            Order order = Order.builder()&#10;                    .orderCode(orderCode)&#10;                    .userId(sender.getId())&#10;                    .receiverId(receiver.getId())&#10;                    .tripId(trip.getId())&#10;                    .productId(savedProduct.getId())&#10;                    .price(BigDecimal.ZERO)&#10;                    .status(&quot;PENDING&quot;)&#10;                    .createdAt(LocalDateTime.now())&#10;                    .build();&#10;&#10;            Order savedOrder = orderRepository.save(order);&#10;&#10;            // Build response with usernames from retrieved User objects&#10;            OrderResponse response = OrderResponse.builder()&#10;                    .orderId(savedOrder.getId())&#10;                    .orderCode(savedOrder.getOrderCode())&#10;                    .senderUsername(sender.getUsername())&#10;                    .receiverUsername(receiver.getUsername())&#10;                    .productName(savedProduct.getCode())&#10;                    .robotCode(request.getRobotCode())&#10;                    .robotContainerCode(request.getRobotContainerCode())&#10;                    .endpoint(request.getEndpoint())&#10;                    .price(savedOrder.getPrice())&#10;                    .status(savedOrder.getStatus())&#10;                    .createdAt(savedOrder.getCreatedAt())&#10;                    .completedAt(savedOrder.getCompletedAt())&#10;                    .build();&#10;&#10;            responses.add(response);&#10;        }&#10;&#10;        log.info(&quot;Successfully created {} orders in batch for sender: {}&quot;, responses.size(), request.getSenderIdentifier());&#10;        return responses;&#10;    }&#10;&#10;    /**&#10;     * Find user by email, phone number, or username&#10;     * This method supports flexible user identification using email, phone, or username&#10;     */&#10;    private Optional&lt;User&gt; findUserByIdentifier(String identifier) {&#10;        if (identifier == null || identifier.trim().isEmpty()) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        identifier = identifier.trim();&#10;&#10;        // Check if identifier looks like an email (contains @)&#10;        if (identifier.contains(&quot;@&quot;)) {&#10;            log.debug(&quot;Looking up user by email: {}&quot;, identifier);&#10;            return userRepository.findByEmail(identifier);&#10;        } else {&#10;            // First try to find by phone&#10;            log.debug(&quot;Looking up user by phone: {}&quot;, identifier);&#10;            Optional&lt;User&gt; userByPhone = userRepository.findByPhone(identifier);&#10;&#10;            // If not found by phone, try by username&#10;            if (userByPhone.isEmpty()) {&#10;                log.debug(&quot;Not found by phone, looking up user by username: {}&quot;, identifier);&#10;                return userRepository.findByUsername(identifier);&#10;            }&#10;&#10;            return userByPhone;&#10;        }&#10;    }&#10;&#10;    private void validateRobotAvailability(String robotCode, String robotContainerCode) {&#10;        // Check if robot is online using cached data&#10;        if (!robotDataService.isRobotOnline(robotCode)) {&#10;            throw new RuntimeException(&quot;Robot &quot; + robotCode + &quot; is not online&quot;);&#10;        }&#10;&#10;        // Check robot status using cached data&#10;        Optional&lt;RobotStatusDTO&gt; robotStatusOpt = robotDataService.getStatus(robotCode);&#10;        if (robotStatusOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Robot &quot; + robotCode + &quot; status not available&quot;);&#10;        }&#10;&#10;        RobotStatusDTO robotStatus = robotStatusOpt.get();&#10;        if (!&quot;free&quot;.equalsIgnoreCase(robotStatus.getStatus())) {&#10;            throw new RuntimeException(&quot;Robot &quot; + robotCode + &quot; is not available (status: &quot; + robotStatus.getStatus() + &quot;)&quot;);&#10;        }&#10;&#10;        // Check container status using cached data&#10;        Optional&lt;RobotContainerStatusDTO&gt; containerStatusOpt =&#10;                robotDataService.getContainerStatus(robotCode, robotContainerCode);&#10;        if (containerStatusOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Container &quot; + robotContainerCode + &quot; status not available for robot &quot; + robotCode);&#10;        }&#10;&#10;        RobotContainerStatusDTO containerStatus = containerStatusOpt.get();&#10;        if (!&quot;free&quot;.equalsIgnoreCase(containerStatus.getStatus())) {&#10;            throw new RuntimeException(&quot;Container &quot; + robotContainerCode + &quot; is not available (status: &quot; + containerStatus.getStatus() + &quot;)&quot;);&#10;        }&#10;&#10;        log.info(&quot;Robot {} and container {} are available for order&quot;, robotCode, robotContainerCode);&#10;    }&#10;&#10;    private Trip findOrCreateActiveTrip(String robotCode, String robotContainerCode, String startPoint, String endpoint, UUID userId) {&#10;        // Look for an active trip for the robot code - uses JOIN query to avoid lazy loading issues&#10;        Optional&lt;Trip&gt; activeTrip = tripRepository.findActiveByRobotCode(robotCode);&#10;&#10;        if (activeTrip.isPresent()) {&#10;            Trip existingTrip = activeTrip.get();&#10;            // Update trip with start point, endpoint, user ID, and robot container ID if not already set&#10;            if (existingTrip.getStartPoint() == null || existingTrip.getEndPoint() == null ||&#10;                existingTrip.getUserId() == null || existingTrip.getRobotContainerId() == null) {&#10;&#10;                if (existingTrip.getStartPoint() == null) {&#10;                    existingTrip.setStartPoint(startPoint);&#10;                }&#10;                if (existingTrip.getEndPoint() == null) {&#10;                    existingTrip.setEndPoint(endpoint);&#10;                }&#10;                if (existingTrip.getUserId() == null) {&#10;                    existingTrip.setUserId(userId);&#10;                }&#10;&#10;                // Get and set robot container ID if not already set&#10;                if (existingTrip.getRobotContainerId() == null) {&#10;                    Long robotContainerId = getRobotContainerIdByCode(robotCode, robotContainerCode);&#10;                    existingTrip.setRobotContainerId(robotContainerId);&#10;                }&#10;&#10;                return tripRepository.save(existingTrip);&#10;            }&#10;            return existingTrip;&#10;        }&#10;&#10;        // For new trip creation, we need the actual robot UUID and container ID from database&#10;        UUID robotId = getRobotIdByCode(robotCode);&#10;        Long robotContainerId = getRobotContainerIdByCode(robotCode, robotContainerCode);&#10;&#10;        // Generate unique trip code&#10;        String tripCode = tripCodeGenerator.generateTripCode();&#10;&#10;        // Create new trip if no active trip exists - starts with PENDING status&#10;        Trip newTrip = Trip.builder()&#10;                .tripCode(tripCode)&#10;                .robotId(robotId)&#10;                .robotContainerId(robotContainerId)&#10;                .userId(userId)&#10;                .startPoint(startPoint)&#10;                .endPoint(endpoint)&#10;                .status(&quot;PENDING&quot;) // Trip starts as PENDING, becomes ACTIVE when robot receives move command&#10;                .startTime(LocalDateTime.now())&#10;                .build();&#10;&#10;        return tripRepository.save(newTrip);&#10;    }&#10;&#10;    private UUID getRobotIdByCode(String robotCode) {&#10;        // Minimal database query to get robot UUID for trip creation only&#10;        // The availability checking was already done using cached data&#10;        Robot robot = robotRepository.findByCode(robotCode)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Robot not found with code: &quot; + robotCode));&#10;        return robot.getId();&#10;    }&#10;&#10;    private Long getRobotContainerIdByCode(String robotCode, String robotContainerCode) {&#10;        // Get robot container ID for trip creation&#10;        return robotContainerRepository.findByRobotCodeAndContainerCode(robotCode, robotContainerCode)&#10;                .map(robotContainer -&gt; robotContainer.getId())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Robot container not found with robot code: &quot; + robotCode + &quot; and container code: &quot; + robotContainerCode));&#10;    }&#10;&#10;    public List&lt;OrderResponse&gt; getAllOrders() {&#10;        log.info(&quot;Retrieving all orders&quot;);&#10;&#10;        Iterable&lt;Order&gt; orderIterable = orderRepository.findAll();&#10;        List&lt;Order&gt; orders = new ArrayList&lt;&gt;();&#10;        orderIterable.forEach(orders::add);&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;OrderResponse&gt; getOrdersByUsername(String username) {&#10;        log.info(&quot;Retrieving orders for username: {}&quot;, username);&#10;&#10;        List&lt;Order&gt; orders = orderRepository.findByUsername(username);&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get orders where the user is the sender&#10;     */&#10;    public List&lt;OrderResponse&gt; getOrdersBySender(String senderUsername) {&#10;        log.info(&quot;Retrieving orders sent by: {}&quot;, senderUsername);&#10;&#10;        User sender = userRepository.findByUsername(senderUsername)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Sender not found with username: &quot; + senderUsername));&#10;&#10;        List&lt;Order&gt; orders = orderRepository.findByUserId(sender.getId());&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get orders where the user is the receiver&#10;     */&#10;    public List&lt;OrderResponse&gt; getOrdersByReceiver(String receiverUsername) {&#10;        log.info(&quot;Retrieving orders received by: {}&quot;, receiverUsername);&#10;&#10;        User receiver = userRepository.findByUsername(receiverUsername)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Receiver not found with username: &quot; + receiverUsername));&#10;&#10;        List&lt;Order&gt; orders = orderRepository.findByReceiverId(receiver.getId());&#10;&#10;        return orders.stream()&#10;                .map(this::convertToOrderResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get order by order code&#10;     * @param orderCode Order code to search for&#10;     * @return OrderResponse containing order details including price&#10;     */&#10;    public OrderResponse getOrderByOrderCode(String orderCode) {&#10;        log.info(&quot;Retrieving order by order code: {}&quot;, orderCode);&#10;&#10;        Optional&lt;Order&gt; orderOpt = orderRepository.findByOrderCode(orderCode);&#10;        if (orderOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Order not found with code: &quot; + orderCode);&#10;        }&#10;&#10;        Order order = orderOpt.get();&#10;        return convertToOrderResponse(order);&#10;    }&#10;&#10;    private OrderResponse convertToOrderResponse(Order order) {&#10;        // Get product information from product table using product ID&#10;        String productName = &quot;N/A&quot;;&#10;        String robotContainerCode = &quot;N/A&quot;;&#10;        if (order.getProductId() != null) {&#10;            Optional&lt;Product&gt; product = productRepository.findById(order.getProductId());&#10;            if (product.isPresent()) {&#10;                productName = product.get().getCode(); // Using product code as product name&#10;                robotContainerCode = product.get().getContainerCode();&#10;            }&#10;        }&#10;&#10;        // Get robot code, start point, and endpoint from trip information&#10;        String robotCode = &quot;N/A&quot;;&#10;        String startPoint = &quot;N/A&quot;;&#10;        String endpoint = &quot;N/A&quot;;&#10;        if (order.getTripId() != null) {&#10;            Optional&lt;Trip&gt; trip = tripRepository.findById(order.getTripId());&#10;            if (trip.isPresent()) {&#10;                startPoint = trip.get().getStartPoint();&#10;                endpoint = trip.get().getEndPoint();&#10;                // Get robot code from robot table using robot ID&#10;                if (trip.get().getRobotId() != null) {&#10;                    Optional&lt;Robot&gt; robot = robotRepository.findById(trip.get().getRobotId());&#10;                    if (robot.isPresent()) {&#10;                        robotCode = robot.get().getCode();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Get sender and receiver usernames&#10;        String senderUsername = &quot;N/A&quot;;&#10;        String receiverUsername = &quot;N/A&quot;;&#10;&#10;        if (order.getUserId() != null) {&#10;            Optional&lt;User&gt; sender = userRepository.findById(order.getUserId());&#10;            if (sender.isPresent()) {&#10;                senderUsername = sender.get().getUsername();&#10;            }&#10;        }&#10;&#10;        if (order.getReceiverId() != null) {&#10;            Optional&lt;User&gt; receiver = userRepository.findById(order.getReceiverId());&#10;            if (receiver.isPresent()) {&#10;                receiverUsername = receiver.get().getUsername();&#10;            }&#10;        }&#10;&#10;        return OrderResponse.builder()&#10;                .orderId(order.getId())&#10;                .orderCode(order.getOrderCode())&#10;                .senderUsername(senderUsername)&#10;                .receiverUsername(receiverUsername)&#10;                .productName(productName) // Product name from product table&#10;                .robotCode(robotCode) // Robot code from robot table via trip&#10;                .robotContainerCode(robotContainerCode) // Container code from product table&#10;                .startPoint(startPoint) // Start point from trip table&#10;                .endpoint(endpoint) // Endpoint from trip table&#10;                .price(order.getPrice())&#10;                .status(order.getStatus())&#10;                .createdAt(order.getCreatedAt())&#10;                .completedAt(order.getCompletedAt())&#10;                .build();&#10;    }&#10;&#10;    public QRCodeResponse generateAndSendQRCode(String orderCode) {&#10;        log.info(&quot;Generating QR code for orderCode: {}&quot;, orderCode);&#10;&#10;        // Find the order by order code&#10;        Optional&lt;Order&gt; orderOpt = orderRepository.findByOrderCode(orderCode);&#10;        if (orderOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Order not found with code: &quot; + orderCode);&#10;        }&#10;&#10;        Order order = orderOpt.get();&#10;&#10;        // Get trip information to find robot code&#10;        String robotCode = &quot;N/A&quot;;&#10;        String tripCode = &quot;N/A&quot;;&#10;        if (order.getTripId() != null) {&#10;            Optional&lt;Trip&gt; trip = tripRepository.findById(order.getTripId());&#10;            if (trip.isPresent()) {&#10;                tripCode = trip.get().getTripCode();&#10;                if (trip.get().getRobotId() != null) {&#10;                    Optional&lt;Robot&gt; robot = robotRepository.findById(trip.get().getRobotId());&#10;                    if (robot.isPresent()) {&#10;                        robotCode = robot.get().getCode();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create QR code data (JSON format with order and trip information)&#10;        String qrData = String.format(&#10;            &quot;{\&quot;orderCode\&quot;:\&quot;%s\&quot;,\&quot;tripCode\&quot;:\&quot;%s\&quot;,\&quot;timestamp\&quot;:\&quot;%s\&quot;}&quot;,&#10;            orderCode, tripCode, LocalDateTime.now()&#10;        );&#10;&#10;        // Generate QR code&#10;        String qrCodeBase64 = qrCodeService.generateQRCode(qrData);&#10;&#10;        // Send QR code to robot via MQTT&#10;        String mqttTopic = String.format(&quot;robot/%s/command/qr&quot;, robotCode);&#10;        String mqttPayload = String.format(&#10;            &quot;{\&quot;orderCode\&quot;:\&quot;%s\&quot;,\&quot;tripCode\&quot;:\&quot;%s\&quot;,\&quot;qrCode\&quot;:\&quot;%s\&quot;}&quot;,&#10;            orderCode, tripCode, qrCodeBase64&#10;        );&#10;&#10;        try {&#10;            mqttCommandPublisher.publish(mqttPayload, mqttTopic);&#10;            log.info(&quot;QR code sent to robot {} via MQTT topic: {}&quot;, robotCode, mqttTopic);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to send QR code to robot {}: {}&quot;, robotCode, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Failed to send QR code to robot&quot;, e);&#10;        }&#10;&#10;        return QRCodeResponse.builder()&#10;                .orderCode(orderCode)&#10;                .qrCodeBase64(qrCodeBase64)&#10;                .robotCode(robotCode)&#10;                .message(&quot;QR code generated and sent to robot successfully&quot;)&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Verify OTP and complete order&#10;     * Sets order status to FINISHED and trip status to COMPLETED&#10;     * @param orderCode Order code to verify&#10;     * @param otp OTP to verify&#10;     */&#10;    @Transactional&#10;    public void verifyOTPAndCompleteOrder(String orderCode, String otp) {&#10;        log.info(&quot;Verifying OTP for orderCode: {}&quot;, orderCode);&#10;&#10;        // Find the order by order code&#10;        Optional&lt;Order&gt; orderOpt = orderRepository.findByOrderCode(orderCode);&#10;        if (orderOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Order not found with code: &quot; + orderCode);&#10;        }&#10;&#10;        Order order = orderOpt.get();&#10;&#10;        // TODO: Implement actual OTP verification logic here&#10;        // For now, accepting any non-empty OTP as valid&#10;        boolean isOtpValid = otp != null &amp;&amp; !otp.trim().isEmpty();&#10;&#10;        if (!isOtpValid) {&#10;            throw new RuntimeException(&quot;Invalid OTP provided&quot;);&#10;        }&#10;&#10;        // Update order status to FINISHED and set completion time&#10;        order.setStatus(&quot;FINISHED&quot;);&#10;        order.setCompletedAt(LocalDateTime.now());&#10;        orderRepository.save(order);&#10;        log.info(&quot;Order {} status set to FINISHED&quot;, orderCode);&#10;&#10;        // Update trip status to COMPLETED using TripStatusService&#10;        if (order.getTripId() != null) {&#10;            Optional&lt;Trip&gt; tripOpt = tripRepository.findById(order.getTripId());&#10;            if (tripOpt.isPresent()) {&#10;                Trip trip = tripOpt.get();&#10;                String tripCode = trip.getTripCode();&#10;                if (tripCode != null) {&#10;                    tripStatusService.completeTripByOtpVerification(tripCode);&#10;                    log.info(&quot;Trip {} status set to COMPLETED via TripStatusService&quot;, tripCode);&#10;                } else {&#10;                    log.warn(&quot;Trip code is null for trip ID: {}&quot;, trip.getId());&#10;                }&#10;            } else {&#10;                log.warn(&quot;Trip not found for order: {}&quot;, orderCode);&#10;            }&#10;        } else {&#10;            log.warn(&quot;No trip associated with order: {}&quot;, orderCode);&#10;        }&#10;&#10;        log.info(&quot;Successfully completed OTP verification for order {} and associated trip&quot;, orderCode);&#10;    }&#10;&#10;&#10;    public boolean approveOrder(String orderCode) {&#10;        log.info(&quot;Approving order with orderCode: {}&quot;, orderCode);&#10;        if (orderRepository.findByOrderCode(orderCode).isPresent()) {&#10;            // Update order status to APPROVED&#10;            Order order = orderRepository.findByOrderCode(orderCode).get();&#10;            order.setStatus(&quot;APPROVED&quot;);&#10;            orderRepository.save(order);&#10;            log.info(&quot;Order {} approved successfully&quot;, orderCode);&#10;            return true;&#10;        } else {&#10;            log.warn(&quot;Order with code {} not found for approval&quot;, orderCode);&#10;            return false;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>